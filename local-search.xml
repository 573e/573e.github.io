<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>vi/vim 的基本用法</title>
    <link href="/2021/02/03/vi&amp;im/"/>
    <url>/2021/02/03/vi&amp;im/</url>
    
    <content type="html"><![CDATA[<h1 id="vi-vim-的基本用法"><a href="#vi-vim-的基本用法" class="headerlink" title="vi/vim 的基本用法"></a>vi/vim 的基本用法</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。</p><p>但是目前我们使用比较多的是 vim 编辑器。</p><p>vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</p><p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p><p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。</p><p>连 vim 的官方网站 (<a href="http://www.vim.org/">http://www.vim.org</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/vi-vim-cheat-sheet-sch.gif"></p><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><p>一般模式可用的光标移动、复制粘贴、搜索替换等</p><table><thead><tr><th align="left">移动光标的方法</th><th>说明</th></tr></thead><tbody><tr><td align="left">h 或 向左箭头键(←)</td><td>光标向左移动一个字符</td></tr><tr><td align="left">j 或 向下箭头键(↓)</td><td>光标向下移动一个字符</td></tr><tr><td align="left">k 或 向上箭头键(↑)</td><td>光标向上移动一个字符</td></tr><tr><td align="left">l 或 向右箭头键(→)</td><td>光标向右移动一个字符</td></tr><tr><td align="left">如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！</td><td></td></tr><tr><td align="left">[Ctrl] + [f]</td><td>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="left">[Ctrl] + [b]</td><td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="left">[Ctrl] + [d]</td><td>屏幕『向下』移动半页</td></tr><tr><td align="left">[Ctrl] + [u]</td><td>屏幕『向上』移动半页</td></tr><tr><td align="left">+</td><td>光标移动到非空格符的下一行</td></tr><tr><td align="left">-</td><td>光标移动到非空格符的上一行</td></tr><tr><td align="left">n<space></td><td>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td></tr><tr><td align="left">0 或功能键[Home]</td><td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="left">$ 或功能键[End]</td><td>移动到这一行的最后面字符处(常用)</td></tr><tr><td align="left">H</td><td>光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="left">M</td><td>光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="left">L</td><td>光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="left">G</td><td>移动到这个档案的最后一行(常用)</td></tr><tr><td align="left">nG</td><td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="left">gg</td><td>移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td align="left">n<Enter></td><td>n 为数字。光标向下移动 n 行(常用)</td></tr></tbody></table><table><thead><tr><th align="left">搜索替换</th><th>说明</th></tr></thead><tbody><tr><td align="left">/word</td><td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)</td></tr><tr><td align="left">?word</td><td>向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="left">n</td><td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="left">N</td><td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td align="left">使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！</td><td></td></tr><tr><td align="left">:n1,n2s/word1/word2/g</td><td>n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用)</td></tr><tr><td align="left"><strong>:1,$s/word1/word2/g</strong> 或 <strong>:%s/word1/word2/g</strong></td><td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td align="left"><strong>:1,$s/word1/word2/gc</strong> 或 <strong>:%s/word1/word2/gc</strong></td><td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr></tbody></table><table><thead><tr><th align="left">删除、复制与贴上</th><th>说明</th></tr></thead><tbody><tr><td align="left">x, X</td><td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="left">nx</td><td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="left">dd</td><td>删除游标所在的那一整行(常用)</td></tr><tr><td align="left">ndd</td><td>n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)</td></tr><tr><td align="left">d1G</td><td>删除光标所在到第一行的所有数据</td></tr><tr><td align="left">dG</td><td>删除光标所在到最后一行的所有数据</td></tr><tr><td align="left">d$</td><td>删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="left">d0</td><td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="left">yy</td><td>复制游标所在的那一行(常用)</td></tr><tr><td align="left">nyy</td><td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="left">y1G</td><td>复制游标所在行到第一行的所有数据</td></tr><tr><td align="left">yG</td><td>复制游标所在行到最后一行的所有数据</td></tr><tr><td align="left">y0</td><td>复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="left">y$</td><td>复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="left">p, P</td><td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td align="left">J</td><td>将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="left">c</td><td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="left">u</td><td>复原前一个动作。(常用)</td></tr><tr><td align="left">[Ctrl]+r</td><td>重做上一个动作。(常用)</td></tr><tr><td align="left">这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！</td><td></td></tr><tr><td align="left">.</td><td>不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><h2 id="第二部分：一般模式切换到编辑模式的可用的按钮说明"><a href="#第二部分：一般模式切换到编辑模式的可用的按钮说明" class="headerlink" title="第二部分：一般模式切换到编辑模式的可用的按钮说明"></a>第二部分：一般模式切换到编辑模式的可用的按钮说明</h2><table><thead><tr><th align="left">指令行的储存、离开等指令</th><th>说明</th></tr></thead><tbody><tr><td align="left">:w</td><td>将编辑的数据写入硬盘档案中(常用)</td></tr><tr><td align="left">:w!</td><td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</td></tr><tr><td align="left">:q</td><td>离开 vi (常用)</td></tr><tr><td align="left">:q!</td><td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td></tr><tr><td align="left">注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</td><td></td></tr><tr><td align="left">:wq</td><td>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td></tr><tr><td align="left">ZZ</td><td>这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出)</td></tr><tr><td align="left">ZQ</td><td>不保存，强制退出。效果等同于 **:q!**。</td></tr><tr><td align="left">:w [filename]</td><td>将编辑的数据储存成另一个档案（类似另存新档）</td></tr><tr><td align="left">:r [filename]</td><td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td></tr><tr><td align="left">:n1,n2 w [filename]</td><td>将 n1 到 n2 的内容储存成 filename 这个档案。</td></tr><tr><td align="left">:! command</td><td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！</td></tr></tbody></table><table><thead><tr><th align="left">vim 环境的变更</th><th>说明</th></tr></thead><tbody><tr><td align="left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td align="left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><p><strong>特别注意，在 vi/vim 中，数字是很有意义的！数字通常代表重复做几次的意思！ 也有可能是代表去到第几个什么什么的意思。</strong></p><p><strong>举例来说，要删除 50 行，则是用 『50dd』 对吧！ 数字加在动作之前，如我要向下移动 20 行呢？那就是『20j』或者是『20↓』即可。</strong></p><h2 id="批量添加注释"><a href="#批量添加注释" class="headerlink" title="批量添加注释"></a>批量添加注释</h2><p><strong>方法一 ：块选择模式</strong></p><p>批量注释：</p><p><strong>Ctrl + v</strong> 进入块选择模式，然后移动光标选中你要注释的行，再按大写的 <strong>I</strong> 进入行首插入模式输入注释符号如 <strong>//</strong> 或 <strong>#**，输入完毕之后，按两下 **ESC</strong>，<strong>Vim</strong> 会自动将你选中的所有行首都加上注释，保存退出完成注释。</p><p>取消注释：</p><p><strong>Ctrl + v</strong> 进入块选择模式，选中你要删除的行首的注释符号，注意 <strong>//</strong> 要选中两个，选好之后按 <strong>d</strong> 即可删除注释，<strong>ESC</strong> 保存退出。</p><p><strong>方法二：替换命令</strong></p><p>批量注释。</p><p>使用下面命令在指定的行首添加注释。</p><p>使用名命令格式： <strong>:起始行号,结束行号s/^/注释符/g</strong>（注意冒号）。</p><p>取消注释：</p><p>使用名命令格式： <strong>:起始行号,结束行号s/^注释符//g</strong>（注意冒号）。</p><p><strong>例子：</strong></p><ul><li>在 10 - 20 行添加 <strong>//</strong> 注释</li></ul><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs linux">:10,20s#^#&#x2F;&#x2F;#g<br></code></pre></div></td></tr></table></figure><ul><li>在 10 - 20 行删除 <strong>//</strong> 注释</li></ul><figure class="highlight clean"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs clean">:<span class="hljs-number">10</span>,<span class="hljs-number">20</span>s#^<span class="hljs-comment">//##g</span><br></code></pre></div></td></tr></table></figure><ul><li>10 - 20 行添加 <strong>#</strong> 注释</li></ul><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">:<span class="hljs-number">10</span>,<span class="hljs-number">20</span>s<span class="hljs-regexp">/^/</span><span class="hljs-comment">#/g</span><br></code></pre></div></td></tr></table></figure><ul><li>在 <strong>10 - 20</strong> 行删除 # 注释</li></ul><figure class="highlight clean"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs clean">:<span class="hljs-number">10</span>,<span class="hljs-number">20</span>s/#<span class="hljs-comment">//g</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM面试问题总结</title>
    <link href="/2021/01/13/JVM%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2021/01/13/JVM%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM-篇"><a href="#JVM-篇" class="headerlink" title="JVM 篇"></a>JVM 篇</h1><h2 id="1-什么情况下会发生栈内存溢出"><a href="#1-什么情况下会发生栈内存溢出" class="headerlink" title="1. 什么情况下会发生栈内存溢出"></a>1. 什么情况下会发生栈内存溢出</h2><p>在 HotSpot 虚拟机中是不区分虚拟机栈和本地方法栈，栈是线程私有的，它的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈桢在虚拟机栈中入栈到出栈的过程。本地方法栈与虚拟机栈相似，区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</p><p>栈内存溢出是指线程请求的栈深度大于虚拟机所允许的最大深度，则将抛出 StackOverflowError 异常（StackOverflowError 不属于 OOM 异常）。最有可能的原因就是方法递归产生的这种结果。</p><p>另一个可能是引用了大的变量，在拓展栈时无法申请到足够的内存空间，则抛出 OutOfMemoryError 异常（这个属于内存溢出）。</p><h2 id="2-JVM-的内存结构，Eden-和-Survivor-比例"><a href="#2-JVM-的内存结构，Eden-和-Survivor-比例" class="headerlink" title="2. JVM 的内存结构，Eden 和 Survivor 比例"></a>2. JVM 的内存结构，Eden 和 Survivor 比例</h2><p>Java 虚拟机在执行 Java 程序的过程中把它所管理的内存划分为若干个不同的数 据区域，这些区域都有各自的用途。</p><ul><li>程序计数器。当前线程执行的字节码的行号指示器，是线程私有的。也是唯一一个不会发生内存溢出的区域。</li><li>Java 虚拟机栈。也是线程私有的，描述的是 Java 方法执行的内存模型，线程请求的栈深度大于虚拟机所允许的最大深度，则将抛出StackOverflowError 异常。</li><li>本地方法栈。与虚拟机栈相似，区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</li><li>Java 堆。是 Java 虚拟机中管理的内存中最大的一块，所有线程共享区域，唯一目的就是存放对象实例。所有的对象实例以及<strong>数组</strong>都要在堆上分配内存。Java 堆也是垃圾回收器管理的主要区域，也被称为 gc 堆，收集器基本都采用分代收集算法，Java 堆中还可以细分为：新生代和老年代。</li><li>方法区。所有线程共享区域，用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。很多人也愿意称之为“永久代”。</li><li>运行时常量池。是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。</li><li>直接内存。并不是虚拟机运行时数据区的一部分。例如 NIO，它可以使用 Native 函数直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样避免了在 Java 堆和 Native 堆中来回复制数据，提高了性能。</li></ul><p>JVM 中要对堆进行分代，分代的理由是优化 GC 性能，很多对象都是朝生夕死的，如果分代的话，我们把新创建的对象放到某一地方，当 GC 的时候先把这块存“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p><p>HotSpot JVM 把新生代分为了三部分：1个 Eden 区和 2 个Survivor 区（分别叫 from 和 to）。默认比例为 8  ：1。一般情况下，新创建的对象都会被分配到Eden 区(一些大对象特殊处理),这些对象经过第一次 Minor GC后，如果仍然存活，将会被移到 Survivor 区。对象在 Survivor 区中每熬过一次Minor GC，年龄就会增加 1 岁，当它的年龄增加到一定程度时，就会被移动到年老代中。</p><p>因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制]算法不会产生内存碎片。</p><h2 id="3-JVM-内存为什么要分成新生代、老年代和持久代。新生代中为什么要分-Eden-和-Survivor。"><a href="#3-JVM-内存为什么要分成新生代、老年代和持久代。新生代中为什么要分-Eden-和-Survivor。" class="headerlink" title="3. JVM 内存为什么要分成新生代、老年代和持久代。新生代中为什么要分 Eden 和 Survivor。"></a>3. JVM 内存为什么要分成新生代、老年代和持久代。新生代中为什么要分 Eden 和 Survivor。</h2><p>堆内存是虚拟机管理的内存中最大的一块，也是垃圾回收最频繁的一块区域，我们程序所有的对象实例都存放在堆内存中。给堆内存分代是为了提高对象内存分配和垃圾回收的效率。试想一下，如果堆内存没有区域划分，所有的新创建的对象和生命周期很长的对象放在一起，随着程序的执行，堆内存需要频繁进行垃圾收集，而每次回收都要遍历所有的对象，遍历这些对象所花费的时间代价是巨大的，会严重影响我们的 GC 效率，这简直太可怕了。</p><p>有了内存分代，情况就不同了，新创建的对象会在新生代中分配内存，经过多次回收仍然存活下来的对象存放在老年代中，静态属性、类信息等存放在永久代中，新生代中的对象存活时间短，只需要在新生代区域中频繁进行 GC，老年代中对象生命周期长，内存回收的频率相对较低，不需要频繁进行回收，永久代中回收效果太差，一般不进行垃圾回收，还可以根据不同年代的特点采用合适的垃圾收集算法。分代收集大大提升了收集效率，这些都是内存分代带来的好处。</p><p>HotSpot 将新生代划分为三块，一块较大的 Eden 空间和两块较小的 Survivor 空间，默认比例为 8：1：1。划分的目的是因为 HotSpot 采用复制算法来回收新生代，设置这个比例是为了充分利用内存空间，减少浪费。新生成的对象在Eden 区分配（大对象除外，大对象直接进入老年代），当 Eden 区没有足够的空间进行分配时，虚拟机将发起一次 Minor GC。</p><h2 id="4-JVM-中一次完整的-GC-流程是什么样子的，对象如何晋升到老年代，说说你知道的几种主要的-JVM-参数。"><a href="#4-JVM-中一次完整的-GC-流程是什么样子的，对象如何晋升到老年代，说说你知道的几种主要的-JVM-参数。" class="headerlink" title="4. JVM 中一次完整的 GC 流程是什么样子的，对象如何晋升到老年代，说说你知道的几种主要的 JVM 参数。"></a>4. JVM 中一次完整的 GC 流程是什么样子的，对象如何晋升到老年代，说说你知道的几种主要的 JVM 参数。</h2><p>GC 开始时，对象只会存在于 Eden 区和 From Survivor 区，To Survivor 区是空的（作为保留区域）。GC 进行时，Eden 区中所有存活的对象都会被复制到 To Survivor 区，而在 From Survivor 区中，仍存活的对象会根据它们的年龄值决定去向，年龄值达到年龄阀值（默认为 15，新生代中的对象每熬过一轮垃圾回收，年龄值就加 1，GC 分代年龄存储在对象的 header 中）的对象会被移到老年代中，没有达到阀值的对象会被复制到 To Survivor 区。接着清空 Eden 区和 From Survivor 区，新生代中存活的对象都在 To Survivor 区。接着， From Survivor 区和 To Survivor 区会交换它们的角色，也就是新的 To Survivor 区就是上次 GC 清空的 From Survivor 区，新的 From Survivor 区就是上次 GC 的 To Survivor 区，总之，不管怎样都会保证 To Survivor 区在一轮 GC 后是空的。GC时当 To Survivor 区没有足够的空间存放上一次新生代收集下来的存活对象时，需要依赖老年代进行分配担保，将这些对象存放在老年代中。</p><p>对象晋升老年代有三种可能：</p><ol><li>当对象达到成年，经历过 15 次 GC（默认是 15，可配置），对象就晋升到老年代了。</li><li>大的对象会直接在老年代创建。</li><li>新生代的 Survivor 空间内存不足时，对象可能直接晋升到老年代。</li></ol><p>JVM参数：</p><ul><li>-Xms：初始堆大小</li><li>-Xmx：堆最大内存</li><li>-Xss：栈内存</li><li>-XX:PermSize 初始永久代内存</li><li>-XX:MaxPermSize 最大永久带内存</li></ul><h2 id="5-你知道哪几种垃圾收集器，各自的优缺点，重点讲下-cms-和-G1，包括原理，流程，优缺点。"><a href="#5-你知道哪几种垃圾收集器，各自的优缺点，重点讲下-cms-和-G1，包括原理，流程，优缺点。" class="headerlink" title="5. 你知道哪几种垃圾收集器，各自的优缺点，重点讲下 cms 和 G1，包括原理，流程，优缺点。"></a>5. 你知道哪几种垃圾收集器，各自的优缺点，重点讲下 cms 和 G1，包括原理，流程，优缺点。</h2><p>常见的垃圾收集器主要有以下四种：</p><ul><li>串行收集器（Serial、ParNew 收集器）：简单高效，但它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束，中间停顿时间长。</li><li>并行收集器（Parallel Scavenge 收集器）：吞吐量优先，主要关注点在于精确控制吞吐量，即减少 GC 停顿时间，但收集次数变多。</li><li>CMS：以获取最短回收停顿时间为目标的收集器，并发标记-清除，主要步骤有，初始标记，并发标记，重新标记和并发清除。其中，整个过程耗时最长的并发标记和并发清除过程收集器线程都可以和用户线程一起工作，CMS 收集器的内存回收过程始于用户线程一起并发执行的。重新标记是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。但缺点有，CMS 收集器对 CPU 资源非常敏感，并且无法处理浮动垃圾。</li><li>G1：可预测停顿的收集器，并发标记-整理，主要步骤分为，初始标记，并发标记，最终标记和筛选回收。G1 把内存“化整为零”，并且可以分代收集。注意：CMS 是清除，所以会存在很多的内存碎片。G1 是整理，所以碎片空间较小。</li></ul><h2 id="6-垃圾回收算法的实现原理。"><a href="#6-垃圾回收算法的实现原理。" class="headerlink" title="6. 垃圾回收算法的实现原理。"></a>6. 垃圾回收算法的实现原理。</h2><p>垃圾收集算法主要分为以下三种：</p><ol><li>标记-清除算法：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</li><li>复制算法：将可用内存按容量分为两块（Eden 和 Survivor 空间），每次只使用一块，当这一块内存用完后，就将还活着的对象复制到另外一块上面，然后再把已使用过内存空间一次清理掉。</li><li>标记-整理算法：标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界外的内存。</li></ol><p>需要注意的是，“标记-清除”算法存在两个不足：</p><ul><li>一个是效率问题，标记和清除两个过程的效率都不高；</li><li>另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一个垃圾收集动作。作为对比，复制算法每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</li></ul><h2 id="7-当出现了内存溢出，怎么排错。"><a href="#7-当出现了内存溢出，怎么排错。" class="headerlink" title="7. 当出现了内存溢出，怎么排错。"></a>7. 当出现了内存溢出，怎么排错。</h2><ol><li><p>首先控制台查看错误日志。</p></li><li><p>然后使用 jdk 自带的 VisualVM 来查看系统的堆栈日志（也可以用 jmap 查看堆转储快照）。</p></li><li><p>定位出内存溢出的空间：堆，栈还是永久代（jdk8 后没有永久代的溢出了）。</p></li><li><p>如果是堆内存溢出，看是否创建了超大的对象。</p></li><li><p>如果是栈内存溢出，看是否创建了超大的对象，或者产生了死循环，或者递归调用。</p></li></ol><h2 id="8-JVM-内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。"><a href="#8-JVM-内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。" class="headerlink" title="8. JVM 内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。"></a>8. JVM 内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。</h2><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</p><p>内存屏障是一种 CPU 指令，用于控制特定条件下的重排序和内存可见性问题。Java 编译器也会根据内存屏障的规则禁止重排序。</p><p>happen-before 用来阐述操作之间的内存可见性。在 JMM 中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在 happens-before 关系。具体原则如下：</p><ul><li><p>程序次序法则：线程中的每个动作 A 都 happens-before 于该线程中的每一个动作 B，其中，在程序中，所有的动作 B 都能出现在 A 之后。</p></li><li><p>监视器锁法则：对一个监视器锁的解锁 happens-before 于每一个后续对同一监视器锁的加锁。</p></li><li><p>volatile 变量法则：对 volatile 域的写入操作 happens-before 于每一个后续对同一个域的读写操作。</p></li><li><p>线程启动法则：在一个线程里，对 Thread.start 的调用会 happens-before 于每个启动线程的动作。</p></li><li><p>线程终结法则：线程中的任何动作都 happens-before 于其他线程检测到这个线程已经终结、或者从 Thread.join 调用中成功返回，或Thread.isAlive 返回 false。</p></li><li><p>中断法则：一个线程调用另一个线程的 interrupt happens-before 于被中断的线程发现中断。</p></li><li><p>终结法则：一个对象的构造函数的结束 happens-before 于这个对象 finalizer 的开始。</p></li><li><p>传递性：如果 A happens-before 于 B，且 B happens-before 于 C，则 A happens-before 于 C。</p></li></ul><p>主内存是指所有线程共享的内存空间。</p><p>工作内存是指每个线程特有的内存空间。工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写在主内存中的变量。</p><p>参考链接：<a href="https://www.cnblogs.com/chenyangyao/p/5269622.html">JVM 内存模型、指令重排、内存屏障概念解析</a></p><h2 id="9-讲讲-JAVA-的反射机制"><a href="#9-讲讲-JAVA-的反射机制" class="headerlink" title="9. 讲讲 JAVA 的反射机制"></a>9. 讲讲 JAVA 的反射机制</h2><p>Java 反射说的是在运行状态中，对于任何一个类，我们都能够知道这个类有哪些方法和属性。对于任何一个对象，我们都能够对它的方法和属性进行调用。我们把这种动态获取对象信息和调用对象方法的功能称之为反射机制。</p><h2 id="10-你们线上应用的-JVM-参数有哪些。"><a href="#10-你们线上应用的-JVM-参数有哪些。" class="headerlink" title="10. 你们线上应用的 JVM 参数有哪些。"></a>10. 你们线上应用的 JVM 参数有哪些。</h2><ul><li><p>-Xms512m //初始堆大小</p></li><li><p>-Xmx1024m //最大堆大小</p></li><li><p>-XX:PermSize=640m //设置持久代初始值</p></li><li><p>-XX:MaxPermSize=1280m //设置持久代最大值</p></li><li><p>-XX:NewSize=64m //设置年轻代初始值</p></li><li><p>-XX:MaxNewSize=256m //设置年轻代最大值</p></li><li><p>-verbose:gc //表示输出虚拟机中 GC 的详细情况</p></li><li><p>-XX:+PrintGCDetails //日志输出形式</p></li><li><p>-XX:+PrintGCTimeStamps //日志输出形式</p></li></ul><p>在默认情况下，JVM 初始分配的堆内存大小是物理内存的 1/64，最大分配的堆内存大小是物理内存的 1/4。</p><p>默认空余堆内存小于 40%时，JVM 就会增大堆直到-Xmx 的最大限制；空余堆内存大于 70%时，JVM 会减少堆直到-Xms 的最小限制。</p><p>因此服务器一般设置-Xms、-Xmx 相等，来避免每次 GC 后调整堆的大小。</p><h2 id="11-g1-和-cms-区别，吞吐量优先和响应优先的垃圾收集器选择。"><a href="#11-g1-和-cms-区别，吞吐量优先和响应优先的垃圾收集器选择。" class="headerlink" title="11. g1 和 cms 区别，吞吐量优先和响应优先的垃圾收集器选择。"></a>11. g1 和 cms 区别，吞吐量优先和响应优先的垃圾收集器选择。</h2><p>CMS 是基于“标记-清除”实现的，主要步骤是初始标记，并发标记，重新标记和并发清除。</p><p>G1 是基于“标记-整理”实现的，主要步骤是初始标记，并发标记，最终标记和筛选回收。<br>CMS 的缺点是对 CPU 的要求比较高。</p><p>G1 的缺点是将内存划分了多块，所以对内存段的大小有很大的要求。</p><p>CMS 是清除，所有会有很多的内存碎片。</p><p>G1 是整理，所有碎片空间较小。</p><p>G1 和 CMS 都是响应优先，他们的目的都是尽量控制 stop the world 的时间。</p><p>G1 和 CMS 的 Full GC 都是单线程 mark sweep compact 算法，直到 JDK10 才优化成并行的。</p><p>CMS 目前只用于老年代，而 G1 是将整个 Java 堆划分为多个大小不等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔的了，他们都是一部分 Region（不需要连续）的集合。</p><p>吞吐量优先的话可以选择并行垃圾收集器，Parallel Scavenge 收集器。吞吐量是指 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值。</p><h2 id="12-怎么打印线程栈信息。"><a href="#12-怎么打印线程栈信息。" class="headerlink" title="12. 怎么打印线程栈信息。"></a>12. 怎么打印线程栈信息。</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">StackTraceElement[] elements = (<span class="hljs-keyword">new</span> Throwable()).getStackTrace();<br>StringBuffer buf = <span class="hljs-keyword">new</span> StringBuffer();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;elements.length; i++) &#123;<br>    buf.append(<span class="hljs-string">&quot;\n&quot;</span><br>        + elements[i].getClassName()<span class="hljs-comment">// 打印线程当前执行的详细类名</span><br>        + <span class="hljs-string">&quot;.&quot;</span><br>        + elements[i].getMethodName()<span class="hljs-comment">// 打印线程当前方法名</span><br>        + <span class="hljs-string">&quot;(&quot;</span><br>        + elements[i].getFileName()<span class="hljs-comment">// 打印线程当前执行类的文件名</span><br>        + <span class="hljs-string">&quot;:&quot;</span><br>        + elements[i].getLineNumber()<span class="hljs-comment">// 打印线程当前执行的行数</span><br>        + <span class="hljs-string">&quot;)&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="13-请解释如下-jvm-参数的含义。"><a href="#13-请解释如下-jvm-参数的含义。" class="headerlink" title="13. 请解释如下 jvm 参数的含义。"></a>13. 请解释如下 jvm 参数的含义。</h2><ul><li><p>-server：服务器模式</p></li><li><p>-Xms512m：初始堆空间</p></li><li><p>-Xmx512m：最大堆空间</p></li><li><p>-Xss1024K：栈空间</p></li><li><p>-XX:PermSize=256m：初始永久代空间</p></li><li><p>-XX:MaxPermSize=512m ：最大永久代空间</p></li><li><p>-XX:MaxTenuringThreshold=20：在新生代对象存活次数（经历 Minor GC 的次数）后依旧存活，就会晋升到老年代。</p></li><li><p>-XX:CMSInitiatingOccupancyFraction=80 ：设定 CMS 在对老年代内存占用率达到 80%的时候开始 GC(因为 CMS 会有浮动垃圾,所以一般都较早启动 GC)。</p></li><li><p>-XX:+UseCMSInitiatingOccupancyOnly：只是用设定的回收阈值(上面指定的 80%),如果不指定,JVM 仅在第一次使用设定值,后续则自动调整.</p></li></ul><h2 id="14-Java-中对象创建的几种方式。"><a href="#14-Java-中对象创建的几种方式。" class="headerlink" title="14. Java 中对象创建的几种方式。"></a>14. Java 中对象创建的几种方式。</h2><p>创建对象的方式有四种：</p><ul><li>用 new 关键字创建。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">User user = <span class="hljs-keyword">new</span> User();<br></code></pre></div></td></tr></table></figure><ul><li>调用对象的 clone 方法。</li><li>利用反射，调用 Class 类的或者是 Constructor 类的 newInstance() 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">User user = User.class.newInstance();<br><span class="hljs-comment">// 或者是</span><br>Constructor&lt;User&gt; constructor = User.class.getContructor();<br>User user = constructor.newInstance();<br></code></pre></div></td></tr></table></figure><ul><li>用反序列化，调用 ObjectInputStream 类的 readObject() 方法。</li></ul><h2 id="15-Java中的对象一定在堆上分配内存吗？"><a href="#15-Java中的对象一定在堆上分配内存吗？" class="headerlink" title="15. Java中的对象一定在堆上分配内存吗？"></a>15. Java中的对象一定在堆上分配内存吗？</h2><p>前面我们说过，Java 堆中主要保存了对象实例，但是，随着 JIT 编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p><p>其实，在编译期间，JIT 会对代码做很多优化。其中有一部分优化的目的就是减少内存堆分配压力，其中一种重要的技术叫做逃逸分析。</p><p>如果 JIT 经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。</p><p>参考文章：<a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650121615&idx=1&sn=00d412f68fe58dceab6d13fdfefac113&chksm=f36bb8aec41c31b8d62069e2663345c0452ebdded331616496637e19b2cad72725f6ce90daec&scene=21">深入理解 Java 中的逃逸分析 </a>和 <a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650121307&idx=1&sn=5526473d0248cca8385d2a18ba6b25af&chksm=f36bb97ac41c306c354ebf0335cd2fd77cac03f3434894e4e5b44a01754a5494b04350d26d14&scene=21">对象并不一定都是在堆上分配内存的</a></p><h2 id="16-运行时数据中哪些区域是线程共享的，那些是独享的？"><a href="#16-运行时数据中哪些区域是线程共享的，那些是独享的？" class="headerlink" title="16. 运行时数据中哪些区域是线程共享的，那些是独享的？"></a>16. 运行时数据中哪些区域是线程共享的，那些是独享的？</h2><p>在 JVM 运行时内存区域中，程序计数器、虚拟机栈和本地方法栈是线程独享的。而 Java 堆、方法区是线程共享的。但是值得注意的是，Java 堆其实还为每一个 线程单独分配了一块 TLAB 空间（本地线程分配缓冲），这部分空间在分配时是线程独享的，在使用时是线程共享的。（<a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650124457&idx=1&sn=1c33947700dfb28048df4a913b434077&chksm=f36bad88c41c249ea854b371a1c8597959e2e35c2890bdd6a5945df0b568bdfc980d1dd2cf2b&scene=21">TLAB 介绍</a>）</p><p>创建对象时，内存分配过程如何保证线程安全性？有两种解决方案：</p><ul><li>对分配内存空间的动作做同步处理，采用 CAS 机制，配合失败重试的方式保证更新操作的线程安全性。</li><li>每个线程在 Java 堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块”私有”内存中分配，当这部分区域用完之后，再分配新的”私有”内存。这个本地线程分配缓冲就叫做 TLAB。</li></ul><h2 id="17-Java-中数组是存储在堆上还是栈上。"><a href="#17-Java-中数组是存储在堆上还是栈上。" class="headerlink" title="17. Java 中数组是存储在堆上还是栈上。"></a>17. Java 中数组是存储在堆上还是栈上。</h2><p>在 Java 中，数组同样是一个对象，所以对象在内存中如何存放同样适用于数组；</p><p>所以，数组的实例是保存在堆中，而数组的引用是保存在栈上的。</p><h2 id="18-Java-对象创建的过程是怎么样的？"><a href="#18-Java-对象创建的过程是怎么样的？" class="headerlink" title="18. Java 对象创建的过程是怎么样的？"></a>18. Java 对象创建的过程是怎么样的？</h2><p>对于一个普通的 Java 对象的创建，大致过程如下：</p><ul><li><p>虚拟机遇到 new 指令，到常量池定位到这个类的符号引用。</p></li><li><p>检查符号引用代表的类是否被加载、解析、初始化过 ，如果没有的话，则执行相应的类加载过程。</p></li><li><p>虚拟机为对象分配内存。 根据 Java 内存是否规整，分别通过“指针碰撞”或“空闲列表”来分配。</p></li><li><p>虚拟机将分配到的内存空间都初始化为零值。</p></li><li><p>虚拟机对对象进行必要的设置。</p></li><li><p>执行方法，成员变量进行初始化。</p></li></ul><h2 id="19-怎么获取堆和栈的-dump-文件。"><a href="#19-怎么获取堆和栈的-dump-文件。" class="headerlink" title="19. 怎么获取堆和栈的 dump 文件。"></a>19. 怎么获取堆和栈的 dump 文件。</h2><p>Java Dump，Java 虚拟机的运行时快照。将 Java 虚拟机运行时的状态和信息保存到文件。</p><p>可以使用在服务器上使用 jmap 命令来获取堆 dump，使用 jstack 命令来获取线程的调用栈 dump。</p><p>参考文章：<a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=402296484&idx=1&sn=8e7fc8197a216afb590b17e15f9b721e&chksm=796493854e131a932b3dd53839820eaba022cb87a601062b6bf6a574d742cd8e92a707432173&scene=21">Java 命令学习系列（二）——Jstack </a>和 <a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=402312019&idx=1&sn=97736feb967ecbffb454fa037015ad6d&chksm=7964d6724e135f64a5c0d65e41afbeac45700dd91149375f99071731954e855e13b11cd6c30b&scene=21">Java 命令学习系列（三）——Jmap</a> </p><h2 id="20-Minor-GC-和-Full-GC-的触发条件。"><a href="#20-Minor-GC-和-Full-GC-的触发条件。" class="headerlink" title="20. Minor GC 和 Full GC 的触发条件。"></a>20. Minor GC 和 Full GC 的触发条件。</h2><p>Minor GC 触发条件：当 Eden 区满时，触发 Minor GC。</p><p>Full GC 触发条件：</p><ul><li><p>调用 System.gc 时，系统建议执行 Full GC，但是不必然执行。</p></li><li><p>老年代空间不足。</p></li><li><p>方法区空间不足。</p></li><li><p>concurrent mode failure，当执行 CMS GC 过程时（“标记-清除”，存在内存碎片），同时有对象要放入老年代，而此时老年代空间不足造成的（有时候“空间不足”是 CMS GC 时当前的浮动垃圾过多导致暂时性的空间不足触发 Full GC）。</p></li></ul><h2 id="21-在-Java-语言中，可以作为-GC-Roots-的对象有什么。"><a href="#21-在-Java-语言中，可以作为-GC-Roots-的对象有什么。" class="headerlink" title="21. 在 Java 语言中，可以作为 GC Roots 的对象有什么。"></a>21. 在 Java 语言中，可以作为 GC Roots 的对象有什么。</h2><p>可作为 GC Roots 的对象包括以下几种：</p><ul><li><p>虚拟机栈（栈桢中的本地变量表）中引用的对象。</p></li><li><p>方法区中类静态属性引用的对象。</p></li><li><p>方法区中常量引用的对象。</p></li><li><p>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。</p></li></ul><p>获取 GC Roots 最主要的部分在解决如果快速找到 JVM 栈的栈桢的局部变量表中的局部变量所引用的对象。大致思路是 JVM 采用了 OopMap 这个数据结构记录了 GC Roots，GC 的标记开始的时候，直接用 <strong>OopMap</strong> 就可以获得 GC Roots。OopMap 记录了特定时刻栈上（内存）和寄存器（CPU）的哪些位置是引用，通过这些引用就可以找到堆中的对象，这些对象就是 GC Roots，而不需要一个一个的去判断某个内存位置的值是不是引用。</p><h2 id="22-类加载过程。"><a href="#22-类加载过程。" class="headerlink" title="22. 类加载过程。"></a>22. 类加载过程。</h2><p>Java 虚拟机中类加载的全过程包括：加载、验证、准备、解析和初始化这 5 个阶段。</p><p><strong>加载</strong></p><p>在加载阶段，虚拟机主要完成以下 3 个事情。</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流。（这一步骤就是通过类加载器来实现的）</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各类数据的访问入口。</li></ul><p><strong>验证</strong></p><p>验证时连接阶段的第一步，这一阶段的目的是为了<strong>确保</strong> <strong>Class</strong> <strong>文件的字节流中包含的信息符合当前虚拟机的要求</strong>，并且不会危害虚拟机自身的安全。</p><ul><li>文件格式验证：验证字节流是否符合 Class 文件格式的规范，包括文件头部的魔数因子、class 文件主次版本号、class 文件的 MD5 指纹等。</li><li>元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范。简单来说就是验证 Java 语法的正确性。</li><li>字节码验证：主要验证程序的控制流程，如循环、分支等。</li></ul><p><strong>准备</strong></p><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在<strong>方法区</strong>中分配。需要注意的是，这时候进行内存分配的仅包括<strong>类变量（被</strong> <strong>static</strong> <strong>修饰的变量）</strong>，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。</p><p><strong>解析</strong></p><p>解析阶段是虚拟机在常量池内寻找类、接口、字段和方法的符号引用，并且将这些<strong>符号引用替换为直接引用</strong>的过程。符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。</p><p><strong>初始化</strong></p><p>初始化阶段是类的加载过程的最后一个阶段，该阶段主要做一件事情就是执行()，该方法<strong>会为所有的静态变量赋予正确的值</strong>。</p><h2 id="23-Java-内存泄漏的场景。"><a href="#23-Java-内存泄漏的场景。" class="headerlink" title="23. Java 内存泄漏的场景。"></a>23. Java 内存泄漏的场景。</h2><p>内存泄漏是指，一个不再被程序使用的对象或变量还在内存中占有存储空间。虽然 Java 拥有 GC，但还是会出现内存泄漏。举个例子。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 首先，要明白，GC 它回收的是不可到达的对象，但是，在 static 的集合类中，引用可以到达，但是却有可能对象已经不用了</span><br><br><span class="hljs-comment">// 首先定义一个静态变量</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;Object&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stackOverExam</span><span class="hljs-params">(Object object)</span></span>&#123;<br><span class="hljs-comment">// 当非静态变量被 static 变量持有引用的时候，容易发生内存泄露，因为 object 是一直被 list 引用着的</span><br>    list.add(object);<br>    <span class="hljs-comment">//这里设置为 null 并没有达到释放 object 引用对应对象的效果，毕竟 list 还是持有引用</span><br>    object = <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过上面的代码可以看到，由于 static 指向的对象是不能被垃圾回收器回收的，所以，间接的 object 也是无法被回收的，当业务对象很大而且很多的时候，便有了内存泄漏的风险。所以，可以总结如下规则：</p><p>当全局的静态变量持有局部变量（或者说，大范围的变量持有小范围变量而且小范围变量消耗内存表达、数目变多时），程序便有内存泄漏的风险。一般来说，类似的例子还有，单例模式中的对象，模块之间的调用（后面这个例子提到）等。</p><p>先举一个单例对象的例子。由于单例的静态特征使得其生命周期和应用的生命周期一样长，如果一个对象已经不再被使用，而单例对象还会持有该对象的引用，就会使得该对象不能被正常回收，从而导致了内存泄漏。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singleton;<br><span class="hljs-keyword">private</span> List&lt;Integer&gt; list;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">(List&lt;Integer&gt; list)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.list = list;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">(List&lt;Integer&gt; list)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-keyword">null</span>) &#123;<br>singleton = <span class="hljs-keyword">new</span> Singleton(list);<br>&#125;<br><span class="hljs-keyword">return</span> singleton;<br>&#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>另外再举一个模块调用的例子，现在有两个类 A 和 B，其中 B 的默认构造函数上是需要一个 A 的实例作为参数的，这就让 A 和 B 产生了依赖。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">a = <span class="hljs-keyword">new</span> A();<br>b = <span class="hljs-keyword">new</span> B(a);<br>a = <span class="hljs-keyword">null</span>;<br></code></pre></div></td></tr></table></figure><p>a 是对象 A 的引用，b 是对象 B 的引用，对象 B 同时还依赖对象 A，那么这个时候就可以认为对象 B 是可以到达对象 A 的。当 A 对象的引用 a 置为 null 后， a 不再指向对象 A 的引用了，按理说对象 A 可以 GC 了。但是因为 B 依赖着 A，所以这个时候，A 对象是不可能被回收了，造成了内存泄漏。这个时候可以用弱引用 WeakReference 来代替对象 B，就可以解决了这个问题。如下所示。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">A a = <span class="hljs-keyword">new</span> A();<br>WeakReference wr = <span class="hljs-keyword">new</span> WeakReference(a);<br>a = <span class="hljs-keyword">null</span>;<br></code></pre></div></td></tr></table></figure><h2 id="24-jdk1-8-的虚拟机中内存模型变化。"><a href="#24-jdk1-8-的虚拟机中内存模型变化。" class="headerlink" title="24. jdk1.8 的虚拟机中内存模型变化。"></a>24. jdk1.8 的虚拟机中内存模型变化。</h2><p>在 jdk1.8 中变化最大的是取消了永久区 Perm，而是用元数据空间 Metaspace 来进行替换。需要注意的是，元空间占用的内存不是虚拟机内部的，而是本地内存空间，当然也不是堆内存。这个变化的理由如下： </p><ul><li><p>在 jdk1.8 之前的 HotSpot 实现中，类的元数据如方法数据、方法信息（字节码、栈和变量的大小）、运行时常量池等保存在永久代。32 位默认永久代为 64M，64 位默认 85M，可以通过参数-XX：MaxPermSize 进行设置，一旦类的元数据超过了永久代的大小，就会抛出 OOM 异常了。</p></li><li><p>对永久代的调优过程很困难，因为永久代的大小很难确定，其中涉及到很多因素，如类的总数、常量池大小和方法数量等，而且永久代的护具可能会随着每一次 Full GC 而发生移动。</p></li><li><p>在 jdk1.8 中，类的元数据保存在本地内存中，元空间的最大可分配空间就是系统可用内存空间。</p></li></ul><h2 id="25-频繁-GC-的原因。"><a href="#25-频繁-GC-的原因。" class="headerlink" title="25. 频繁 GC 的原因。"></a>25. 频繁 GC 的原因。</h2><ul><li><p>人为因素，在代码中调用了 System.gc()方法。</p></li><li><p>内存原因，设置的堆大小比较小，可以提高堆的空间，比如说提高最小堆空间-Xms 和最大堆空间-Xmx的大小，当然，最好是针对内存的 DUMP 文件进行分析。</p></li><li><p>框架问题，有些框架内部会调用 gc 方法。</p></li><li><p>其他原因，构建的对象实例化十分频繁并且释放对象较为频繁时，也会引起频繁 gc。</p></li></ul><p>如果线上系统突然产生的运行缓慢问题，如果该问题导致线上系统不可用，那么首先需要做的就是，导出 jstack 和内存信息，然后重启系统，尽快保证系统的可用性。这种情况可能的原因主要有两种：</p><ul><li>代码中某个位置读取数据量较大，导致系统内存耗尽，从而导致 Full GC 次数过多，系统缓慢；</li><li>代码中有比较耗 CPU 的操作，导致 CPU 过高，系统运行缓慢。</li></ul><h2 id="26-高并发时，JVM-调优。"><a href="#26-高并发时，JVM-调优。" class="headerlink" title="26. 高并发时，JVM 调优。"></a>26. 高并发时，JVM 调优。</h2><p>优化虚拟机堆的空间大小，根据实际物理内存的大小进行比例分配，并根据程序调整好新生代和老年代的比例。并且，堆不进行自动扩展。然后使用ParNew（并发）+CMS 进行垃圾回收，在多线程高并发的情况下，表现很好。</p><p>调优的目标是：</p><ul><li><p>将转移到老年代的对象数量降低到最小 。</p></li><li><p>减少 Full GC 的执行时间。</p></li></ul><h2 id="27-System-gc-和-Runtime-gc-的区别。"><a href="#27-System-gc-和-Runtime-gc-的区别。" class="headerlink" title="27. System.gc()和 Runtime.gc()的区别。"></a>27. System.gc()和 Runtime.gc()的区别。</h2><ul><li>java.lang.System.gc()只是 java.lang.Runtime.getRuntime().gc()的简写，两者的行为没有任何不同。</li></ul><ul><li>System.gc()和 runtime.gc()用于建议 jvm 进行垃圾回收，但是否立即回收还是延迟回收由 Java 虚拟机决定。</li></ul><p>另外，当我们调用 System.gc()的时候，其实并不会马上进行垃圾回收，甚至不一定会执行垃圾回收。</p><blockquote><p> 以上主要参考来源为：《深入理解 Java 虚拟机：JVM 高级特征与最佳实践》</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>195-第十行</title>
    <link href="/2020/12/22/195%E7%AC%AC%E5%8D%81%E8%A1%8C/"/>
    <url>/2020/12/22/195%E7%AC%AC%E5%8D%81%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="195-第十行"><a href="#195-第十行" class="headerlink" title="195-第十行"></a>195-第十行</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个文本文件 file.txt，请只打印这个文件中的第十行。</p><p><strong>示例：</strong></p><p>假设 file.txt 有如下内容：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Line</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">Line</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">Line</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">Line</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">Line</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">Line</span> <span class="hljs-number">6</span><br><span class="hljs-attribute">Line</span> <span class="hljs-number">7</span><br><span class="hljs-attribute">Line</span> <span class="hljs-number">8</span><br><span class="hljs-attribute">Line</span> <span class="hljs-number">9</span><br><span class="hljs-attribute">Line</span> <span class="hljs-number">10</span><br></code></pre></div></td></tr></table></figure><p>你的脚本应当显示第十行：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Line</span> <span class="hljs-number">10</span><br></code></pre></div></td></tr></table></figure><p><strong>说明：</strong></p><ol><li>如果文件少于十行，你应当输出什么？</li><li>至少有三种不同的解法，请尝试尽可能多的方法来解题。</li></ol><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 打印第十行</span><br><span class="hljs-comment"># -n: 取消默认的 sed 软件的输出, 通常和 p 一起合用</span><br><span class="hljs-comment"># p: 打印匹配行(通常和 -n 一起合用)</span><br><span class="hljs-comment"># 没有第十行, 什么也不输出</span><br>sed -n <span class="hljs-string">&#x27;10p&#x27;</span> file.txt<br><br><span class="hljs-comment"># 打印一到十行</span><br>sed -n <span class="hljs-string">&#x27;1,10p&#x27;</span> file.txt<br><br><span class="hljs-comment"># 打印第十行</span><br><span class="hljs-comment"># 变量 NR: 已经读出的记录数, 从 1 开始</span><br><span class="hljs-comment"># 没有第十行, 什么也不输出</span><br><span class="hljs-comment"># 更多变量自行百度</span><br>awk <span class="hljs-string">&#x27;NR==10&#x27;</span> file.txt<br><br><span class="hljs-comment"># 打印第十行</span><br><span class="hljs-comment"># 没有第十行, 什么也不输出</span><br>tail -n +10 file.txt | head -1<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>步数🏃‍♂️🏃‍♀️</title>
    <link href="/2020/12/20/Step/"/>
    <url>/2020/12/20/Step/</url>
    
    <content type="html"><![CDATA[<h1 id="步数🏃‍♂️🏃‍♀️"><a href="#步数🏃‍♂️🏃‍♀️" class="headerlink" title="步数🏃‍♂️🏃‍♀️"></a>步数🏃‍♂️🏃‍♀️</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>下载小米运动APP，用<strong>手机号</strong>注册一个账号</li><li>登录APP之后，<strong>第三方数据同步打开</strong></li></ol><p><strong>示例图：</strong></p><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/xiaomi/1.png" alt="准备工作"></p><h2 id="使用云函数"><a href="#使用云函数" class="headerlink" title="使用云函数"></a>使用云函数</h2><ul><li>登录<a href="https://cloud.tencent.com/">腾讯云</a>，这里以腾讯云函数为例，如果是第一次登录，登录之后，可能需要进行实名认证</li><li>搜索 “云函数”，进入管理控制台</li></ul><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/xiaomi/3.png" alt="搜索云函数"></p><ul><li>新建一个函数</li></ul><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/xiaomi/4.png" alt="新建函数"></p><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/xiaomi/5.png" alt="新建函数"></p><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/xiaomi/6.png" alt="新建函数"></p><ul><li>将👆👆👆上图中👆👆👆 index.py 的代码全删掉，<strong>全部替换成我文件(文件底部分享)里 index.py 里的代码</strong>。<strong>记得把账号密码给填上</strong>，在index.py的第68, 69行</li></ul><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/xiaomi/7.png" alt="替换代码"></p><ul><li>新建文件： <strong>data_json.txt</strong>，名字不要改，就是 <strong>data_json.txt</strong></li></ul><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/xiaomi/8.jpg" alt="新建文件"></p><ul><li>将我文件(文件底部分享)里的 data.json_txt 里的内容，<strong>复制到刚刚创建的 data_json.txt</strong></li><li>点击下面的完成就可以测试了，<strong>如果中途修改了代码，记得点击保存</strong></li></ul><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/xiaomi/9.png" alt="测试"></p><ul><li>可以创建函数触发器，每天自动执行，Cron表达式自行查看文档，图中实例是每天13点</li></ul><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/xiaomi/10.png" alt="创建函数触发器"></p><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/xiaomi/11.png" alt="创建函数触发器"></p><ul><li>到此就结束了</li><li>文件：<a href="https://pan.baidu.com/s/1f9R0mS4_9wuL3ELwessSPA">某盘</a>，提取码在评论区</li></ul><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ol><li>步数通知，可以用<strong>QMSG酱</strong>或者<strong>server酱</strong>，用法百度</li><li>微信最大步数<strong>98800</strong>，支付宝最大是<strong>100000</strong>，不要超过这两个值</li><li>支付宝步数达到<strong>17760</strong>，蚂蚁森林能量就能得到296了，通过步数得到的能量上限就是296</li><li>微信步数排行榜被好友举报后，排行榜不会再显示本人步数，多久之后正常显示不知道</li><li><strong style="color:red">不建议改太多 !</strong></li></ol>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>596-超过5名学生的课</title>
    <link href="/2020/12/10/LeetCode-596%E8%B6%85%E8%BF%875%E5%90%8D%E5%AD%A6%E7%94%9F%E7%9A%84%E8%AF%BE/"/>
    <url>/2020/12/10/LeetCode-596%E8%B6%85%E8%BF%875%E5%90%8D%E5%AD%A6%E7%94%9F%E7%9A%84%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="596-超过5名学生的课"><a href="#596-超过5名学生的课" class="headerlink" title="596-超过5名学生的课"></a>596-超过5名学生的课</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个 <strong>course</strong> 表，有：<strong>student (学生)</strong> 和 **class (课程)**。</p><p>请列出所有超过或等于5名学生的课。</p><p><strong>示例：</strong></p><figure class="highlight gherkin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gherkin">+---------+------------+<br>|<span class="hljs-string"> student </span>|<span class="hljs-string"> class      </span>|<br>+---------+------------+<br>|<span class="hljs-string"> A       </span>|<span class="hljs-string"> Math       </span>|<br>|<span class="hljs-string"> B       </span>|<span class="hljs-string"> English    </span>|<br>|<span class="hljs-string"> C       </span>|<span class="hljs-string"> Math       </span>|<br>|<span class="hljs-string"> D       </span>|<span class="hljs-string"> Biology    </span>|<br>|<span class="hljs-string"> E       </span>|<span class="hljs-string"> Math       </span>|<br>|<span class="hljs-string"> F       </span>|<span class="hljs-string"> Computer   </span>|<br>|<span class="hljs-string"> G       </span>|<span class="hljs-string"> Math       </span>|<br>|<span class="hljs-string"> H       </span>|<span class="hljs-string"> Math       </span>|<br>|<span class="hljs-string"> I       </span>|<span class="hljs-string"> Math       </span>|<br>+---------+------------+<br></code></pre></div></td></tr></table></figure><p><strong>应该输出：</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-code">+---------+</span><br>| class   |<br><span class="hljs-code">+---------+</span><br>| Math    |<br><span class="hljs-code">+---------+</span><br></code></pre></div></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>学生在每个课中不应该被重复计算。</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="方法一：使用-GROUP-BY-子句和子查询"><a href="#方法一：使用-GROUP-BY-子句和子查询" class="headerlink" title="方法一：使用 GROUP BY 子句和子查询"></a>方法一：使用 GROUP BY 子句和子查询</h3><p><strong>思路：</strong></p><p>先统计每门课程的学生数量，再从中选择超过 5 名学生的课程。</p><p>使用 <strong>GROUP BY</strong> 和 <strong>COUNT</strong> 获得每门课程的学生数量。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>    class, <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> student)<br><span class="hljs-keyword">FROM</span><br>    courses<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> class<br>;<br></code></pre></div></td></tr></table></figure><p style="color: red; font-weight: bold;">注：使用 DISTINCT 防止在同一门课中学生被重复计算。</p><p><strong>输出结果：</strong></p><figure class="highlight gherkin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gherkin">+----------+----------------+<br>|<span class="hljs-string"> class    </span>|<span class="hljs-string"> COUNT(student) </span>|<br>|<span class="hljs-string">----------</span>|<span class="hljs-string">----------------</span>|<br>|<span class="hljs-string"> Biology  </span>|<span class="hljs-string"> 1              </span>|<br>|<span class="hljs-string"> Computer </span>|<span class="hljs-string"> 1              </span>|<br>|<span class="hljs-string"> English  </span>|<span class="hljs-string"> 1              </span>|<br>|<span class="hljs-string"> Math     </span>|<span class="hljs-string"> 6              </span>|<br>+----------+----------------+<br></code></pre></div></td></tr></table></figure><p>使用上面查询结果的临时表进行子查询，筛选学生数量超过 5 的课程。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>    class<br><span class="hljs-keyword">FROM</span><br>    (<span class="hljs-keyword">SELECT</span><br>        class, <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> student) <span class="hljs-keyword">AS</span> num<br>    <span class="hljs-keyword">FROM</span><br>        courses<br>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> class) <span class="hljs-keyword">AS</span> temp_table<br><span class="hljs-keyword">WHERE</span><br>    num <span class="hljs-operator">&gt;=</span> <span class="hljs-number">5</span><br>;<br></code></pre></div></td></tr></table></figure><h3 id="方法二：使用-GROUP-BY-和-HAVING-条件"><a href="#方法二：使用-GROUP-BY-和-HAVING-条件" class="headerlink" title="方法二：使用 GROUP BY 和 HAVING 条件"></a>方法二：使用 GROUP BY 和 HAVING 条件</h3><p>思路：</p><p>在 <strong>GROUP BY</strong> 子句后使用 <strong>HAVING</strong> 条件是实现子查询的一种更加简单直接的方法。</p><p>所以我们可以将上面的解决方案重写为：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>    class<br><span class="hljs-keyword">FROM</span><br>    courses<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> class<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> student) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">5</span><br>;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>184-部门工资最高的员工</title>
    <link href="/2020/12/09/LeetCode-184%E9%83%A8%E9%97%A8%E5%B7%A5%E8%B5%84%E6%9C%80%E9%AB%98%E7%9A%84%E5%91%98%E5%B7%A5/"/>
    <url>/2020/12/09/LeetCode-184%E9%83%A8%E9%97%A8%E5%B7%A5%E8%B5%84%E6%9C%80%E9%AB%98%E7%9A%84%E5%91%98%E5%B7%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="184-部门工资最高的员工"><a href="#184-部门工资最高的员工" class="headerlink" title="184-部门工资最高的员工"></a>184-部门工资最高的员工</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>Employee</strong> 表包含所有员工信息，每个员工有其对应的 <strong>Id</strong>, <strong>salary</strong> 和 <strong>department Id</strong>。</p><p><strong>示例：</strong></p><figure class="highlight gherkin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gherkin">+----+-------+--------+--------------+<br>|<span class="hljs-string"> Id </span>|<span class="hljs-string"> Name  </span>|<span class="hljs-string"> Salary </span>|<span class="hljs-string"> DepartmentId </span>|<br>+----+-------+--------+--------------+<br>|<span class="hljs-string"> 1  </span>|<span class="hljs-string"> Joe   </span>|<span class="hljs-string"> 70000  </span>|<span class="hljs-string"> 1            </span>|<br>|<span class="hljs-string"> 2  </span>|<span class="hljs-string"> Jim   </span>|<span class="hljs-string"> 90000  </span>|<span class="hljs-string"> 1            </span>|<br>|<span class="hljs-string"> 3  </span>|<span class="hljs-string"> Henry </span>|<span class="hljs-string"> 80000  </span>|<span class="hljs-string"> 2            </span>|<br>|<span class="hljs-string"> 4  </span>|<span class="hljs-string"> Sam   </span>|<span class="hljs-string"> 60000  </span>|<span class="hljs-string"> 2            </span>|<br>|<span class="hljs-string"> 5  </span>|<span class="hljs-string"> Max   </span>|<span class="hljs-string"> 90000  </span>|<span class="hljs-string"> 1            </span>|<br>+----+-------+--------+--------------+<br></code></pre></div></td></tr></table></figure><p><strong>Department</strong> 表包含公司所有部门的信息。</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-code">+----+</span>----------+<br>| Id | Name     |<br><span class="hljs-code">+----+</span>----------+<br>| 1  | IT       |<br>| 2  | Sales    |<br><span class="hljs-code">+----+</span>----------+<br></code></pre></div></td></tr></table></figure><p>编写一个 SQL 查询，找出每个部门工资最高的员工。对于上述表，您的 SQL 查询应返回以下行（行的顺序无关紧要）。</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-code">+------------+</span>----------<span class="hljs-code">+--------+</span><br>| Department | Employee | Salary |<br><span class="hljs-code">+------------+</span>----------<span class="hljs-code">+--------+</span><br>| IT         | Max      | 90000  |<br>| IT         | Jim      | 90000  |<br>| Sales      | Henry    | 80000  |<br><span class="hljs-code">+------------+</span>----------<span class="hljs-code">+--------+</span><br></code></pre></div></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>Max 和 Jim 在 IT 部门的工资都是最高的，Henry 在销售部的工资最高。</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="方法：使用-JOIN-和-IN-子句"><a href="#方法：使用-JOIN-和-IN-子句" class="headerlink" title="方法：使用 JOIN 和 IN 子句"></a>方法：使用 JOIN 和 IN 子句</h3><p><strong>思路：</strong></p><p>因为 <strong>Employee</strong> 表包含 <strong>Salary</strong> 和 <strong>DepartmentId</strong> 字段，我们可以以此在部门内查询最高工资。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>    DepartmentId, <span class="hljs-built_in">MAX</span>(Salary)<br><span class="hljs-keyword">FROM</span><br>    Employee<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> DepartmentId;<br></code></pre></div></td></tr></table></figure><p style="color: red; font-weight: bold;">注意：有可能有多个员工同时拥有最高工资，所以最好在这个查询中不包含雇员名字的信息。</p><figure class="highlight gherkin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gherkin">+--------------+-------------+<br>|<span class="hljs-string"> DepartmentId </span>|<span class="hljs-string"> MAX(Salary) </span>|<br>|<span class="hljs-string">--------------</span>|<span class="hljs-string">-------------</span>|<br>|<span class="hljs-string"> 1            </span>|<span class="hljs-string"> 90000       </span>|<br>|<span class="hljs-string"> 2            </span>|<span class="hljs-string"> 80000       </span>|<br>+--------------+-------------+<br></code></pre></div></td></tr></table></figure><p>然后，我们可以把表 <strong>Employee</strong> 和 <strong>Department</strong> 连接，再在这张临时表里用 <strong>IN</strong> 语句查询部门名字和工资的关系。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>    Department.name <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;Department&#x27;</span>,<br>    Employee.name <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;Employee&#x27;</span>,<br>    Salary<br><span class="hljs-keyword">FROM</span><br>    Employee<br>        <span class="hljs-keyword">JOIN</span><br>    Department <span class="hljs-keyword">ON</span> Employee.DepartmentId <span class="hljs-operator">=</span> Department.Id<br><span class="hljs-keyword">WHERE</span><br>    (Employee.DepartmentId , Salary) <span class="hljs-keyword">IN</span><br>    (   <span class="hljs-keyword">SELECT</span><br>            DepartmentId, <span class="hljs-built_in">MAX</span>(Salary)<br>        <span class="hljs-keyword">FROM</span><br>            Employee<br>        <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> DepartmentId<br>)<br>;<br></code></pre></div></td></tr></table></figure><p>结果</p><figure class="highlight gherkin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gherkin">+------------+----------+--------+<br>|<span class="hljs-string"> Department </span>|<span class="hljs-string"> Employee </span>|<span class="hljs-string"> Salary </span>|<br>|<span class="hljs-string">------------</span>|<span class="hljs-string">----------</span>|<span class="hljs-string">--------</span>|<br>|<span class="hljs-string"> Sales      </span>|<span class="hljs-string"> Henry    </span>|<span class="hljs-string"> 80000  </span>|<br>|<span class="hljs-string"> IT         </span>|<span class="hljs-string"> Max      </span>|<span class="hljs-string"> 90000  </span>|<br>+------------+----------+--------+<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>196-删除重复的电子邮箱</title>
    <link href="/2020/12/08/LeetCode-196%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1/"/>
    <url>/2020/12/08/LeetCode-196%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="196-删除重复的电子邮箱"><a href="#196-删除重复的电子邮箱" class="headerlink" title="196-删除重复的电子邮箱"></a>196-删除重复的电子邮箱</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个 SQL 查询，来删除 Person 表中所有重复的电子邮箱，重复的邮箱里只保留 Id 最小 的那个。</p><p><strong>示例：</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-code">+----+</span>------------------+<br>| Id | Email            |<br><span class="hljs-code">+----+</span>------------------+<br>| 1  | john@example.com |<br>| 2  | bob@example.com  |<br>| 3  | john@example.com |<br><span class="hljs-code">+----+</span>------------------+<br>Id 是这个表的主键。<br></code></pre></div></td></tr></table></figure><p><strong>在运行你的SQL语句之后，上面的 Person 表应返回以下几行：</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-code">+----+</span>------------------+<br>| Id | Email            |<br><span class="hljs-code">+----+</span>------------------+<br>| 1  | john@example.com |<br>| 2  | bob@example.com  |<br><span class="hljs-code">+----+</span>------------------+<br></code></pre></div></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>执行 SQL 之后，输出是整个 Person 表。</li><li>使用 delete 语句。</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="方法：使用-DELETE-和-WHERE-子句"><a href="#方法：使用-DELETE-和-WHERE-子句" class="headerlink" title="方法：使用 DELETE 和 WHERE 子句"></a>方法：使用 DELETE 和 WHERE 子句</h3><p><strong>思路：</strong></p><p>我们可以使用以下代码，将此表与它自身在电子邮箱列中连接起来。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> p1.<span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> Person p1,<br>    Person p2<br><span class="hljs-keyword">WHERE</span><br>    p1.Email <span class="hljs-operator">=</span> p2.Email<br>;<br></code></pre></div></td></tr></table></figure><p>然后我们需要找到其他记录中具有相同电子邮件地址的更大 ID。所以我们可以像这样给 WHERE 子句添加一个新的条件。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> p1.<span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> Person p1,<br>    Person p2<br><span class="hljs-keyword">WHERE</span><br>    p1.Email <span class="hljs-operator">=</span> p2.Email <span class="hljs-keyword">AND</span> p1.Id <span class="hljs-operator">&gt;</span> p2.Id<br>;<br></code></pre></div></td></tr></table></figure><p>因为我们已经得到了要删除的记录，所以我们最终可以将该语句更改为 <strong>DELETE</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> p1 <span class="hljs-keyword">FROM</span> Person p1,<br>    Person p2<br><span class="hljs-keyword">WHERE</span><br>    p1.Email <span class="hljs-operator">=</span> p2.Email <span class="hljs-keyword">AND</span> p1.Id <span class="hljs-operator">&gt;</span> p2.Id<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>182-查找重复的电子邮箱</title>
    <link href="/2020/12/07/LeetCode-182%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1/"/>
    <url>/2020/12/07/LeetCode-182%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="182-查找重复的电子邮箱"><a href="#182-查找重复的电子邮箱" class="headerlink" title="182-查找重复的电子邮箱"></a>182-查找重复的电子邮箱</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个 SQL 查询，查找 Person 表中重复的电子邮箱。</p><p><strong>示例：</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-code">+----+</span>---------+<br>| Id | Email   |<br><span class="hljs-code">+----+</span>---------+<br>| 1  | a@b.com |<br>| 2  | c@d.com |<br>| 3  | a@b.com |<br><span class="hljs-code">+----+</span>---------+<br></code></pre></div></td></tr></table></figure><p><strong>根据以上输入，你的查询应返回以下结果</strong>：</p><figure class="highlight asciidoc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-code">+---------+</span><br>| Email   |<br><span class="hljs-code">+---------+</span><br>| a@b.com |<br><span class="hljs-code">+---------+</span><br></code></pre></div></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>所有的电子邮箱都是小写字母。</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="方法一：使用-GROUP-BY-和临时表"><a href="#方法一：使用-GROUP-BY-和临时表" class="headerlink" title="方法一：使用 GROUP BY 和临时表"></a>方法一：使用 GROUP BY 和临时表</h3><p>重复的电子邮箱存在多次。要计算每封电子邮箱的存在次数，我们可以使用以下代码。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> Email, <span class="hljs-built_in">count</span>(Email) <span class="hljs-keyword">as</span> num<br><span class="hljs-keyword">from</span> Person<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> Email;<br></code></pre></div></td></tr></table></figure><p>输出结果：</p><figure class="highlight gherkin"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gherkin">+---------+-----+<br>|<span class="hljs-string"> Email   </span>|<span class="hljs-string"> num </span>|<br>|<span class="hljs-string">---------</span>|<span class="hljs-string">-----</span>|<br>|<span class="hljs-string"> a@b.com </span>|<span class="hljs-string"> 2   </span>|<br>|<span class="hljs-string"> c@d.com </span>|<span class="hljs-string"> 1   </span>|<br>+---------+-----+<br></code></pre></div></td></tr></table></figure><p>以此作为临时表，我们可以得到下面的解决方案。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> Email <span class="hljs-keyword">from</span><br>(<br>  <span class="hljs-keyword">select</span> Email, <span class="hljs-built_in">count</span>(Email) <span class="hljs-keyword">as</span> num<br>  <span class="hljs-keyword">from</span> Person<br>  <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> Email<br>) <span class="hljs-keyword">as</span> statistic<br><span class="hljs-keyword">where</span> num <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span><br>;<br></code></pre></div></td></tr></table></figure><h3 id="方法二：使用-GROUP-BY-和-HAVING-条件"><a href="#方法二：使用-GROUP-BY-和-HAVING-条件" class="headerlink" title="方法二：使用 GROUP BY 和 HAVING 条件"></a>方法二：使用 GROUP BY 和 HAVING 条件</h3><p>向 <strong>GROUP BY</strong> 添加条件的一种更常用的方法是使用 <strong>HAVING</strong> 子句，该子句更为简单高效。</p><p>所以我们可以将上面的解决方案重写为：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> Email<br><span class="hljs-keyword">from</span> Person<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> Email<br><span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(Email) <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>808-唯一的摩尔斯密码词</title>
    <link href="/2020/12/06/LeetCode-808%E5%94%AF%E4%B8%80%E7%9A%84%E8%8E%AB%E5%B0%94%E6%96%AF%E5%AF%86%E7%A0%81%E8%AF%8D/"/>
    <url>/2020/12/06/LeetCode-808%E5%94%AF%E4%B8%80%E7%9A%84%E8%8E%AB%E5%B0%94%E6%96%AF%E5%AF%86%E7%A0%81%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-808唯一的摩尔斯密码词"><a href="#LeetCode-808唯一的摩尔斯密码词" class="headerlink" title="LeetCode-808唯一的摩尔斯密码词"></a>LeetCode-808唯一的摩尔斯密码词</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串，比如：”a” 对应 “.-“，”b” 对应 “-…”，”c” 对应 “-.-.” 等等。</p><p>为了方便，将所有26个字母对应的摩尔斯密码表如下：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">[<span class="hljs-string">&quot;.-&quot;</span>,<span class="hljs-string">&quot;-...&quot;</span>,<span class="hljs-string">&quot;-.-.&quot;</span>,<span class="hljs-string">&quot;-..&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;..-.&quot;</span>,<span class="hljs-string">&quot;--.&quot;</span>,<span class="hljs-string">&quot;....&quot;</span>,<span class="hljs-string">&quot;..&quot;</span>,<span class="hljs-string">&quot;.---&quot;</span>,<span class="hljs-string">&quot;-.-&quot;</span>,<span class="hljs-string">&quot;.-..&quot;</span>,<span class="hljs-string">&quot;--&quot;</span>,<span class="hljs-string">&quot;-.&quot;</span>,<span class="hljs-string">&quot;---&quot;</span>,<span class="hljs-string">&quot;.--.&quot;</span>,<span class="hljs-string">&quot;--.-&quot;</span>,<span class="hljs-string">&quot;.-.&quot;</span>,<span class="hljs-string">&quot;...&quot;</span>,<span class="hljs-string">&quot;-&quot;</span>,<span class="hljs-string">&quot;..-&quot;</span>,<span class="hljs-string">&quot;...-&quot;</span>,<span class="hljs-string">&quot;.--&quot;</span>,<span class="hljs-string">&quot;-..-&quot;</span>,<span class="hljs-string">&quot;-.--&quot;</span>,<span class="hljs-string">&quot;--..&quot;</span>]<br></code></pre></div></td></tr></table></figure><p>给定一个单词列表，每个单词可以写成每个字母对应的摩尔斯密码的组合。例如，”cba” 可以写成 “-.-..–…”，（即 “-.-.” + “.-“ + “-…” 字符串的结合）。我们将这样一个连接过程称作单词翻译。</p><p>返回我们可以获得所有不同单词翻译的数量。</p><p><strong>示例 ：</strong></p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell">输入：words = [<span class="hljs-string">&quot;gin&quot;</span>, <span class="hljs-string">&quot;zen&quot;</span>, <span class="hljs-string">&quot;gig&quot;</span>, <span class="hljs-string">&quot;msg&quot;</span>]<br>输出：<span class="hljs-number">2</span><br>解释：各单词翻译如下:<br><span class="hljs-string">&quot;gin&quot;</span> -&gt; <span class="hljs-string">&quot;--...-.&quot;</span><br><span class="hljs-string">&quot;zen&quot;</span> -&gt; <span class="hljs-string">&quot;--...-.&quot;</span><br><span class="hljs-string">&quot;gig&quot;</span> -&gt; <span class="hljs-string">&quot;--...--.&quot;</span><br><span class="hljs-string">&quot;msg&quot;</span> -&gt; <span class="hljs-string">&quot;--...--.&quot;</span><br><br>共有 <span class="hljs-number">2</span> 种不同翻译, <span class="hljs-string">&quot;--...-.&quot;</span> 和 <span class="hljs-string">&quot;--...--.&quot;</span>.<br></code></pre></div></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>每个单词表 words 的长度不会超过 100；</li><li>每个单词 words[i] 的长度范围为 [1, 12]；</li><li>每个单词 words[i] 只包含小写字母。</li></ol><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="方法一：哈希集合"><a href="#方法一：哈希集合" class="headerlink" title="方法一：哈希集合"></a>方法一：哈希集合</h3><p><strong>思路及解法</strong></p><p>我们将数组 word 中的每个单词转换为摩尔斯码，并加入哈希集合（HashSet）中，最终的答案即为哈希集合中元素的个数。</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniqueMorseRepresentations</span><span class="hljs-params">(String[] words)</span> </span>&#123;<br>        String[] MORSE = <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;.-&quot;</span>,<span class="hljs-string">&quot;-...&quot;</span>,<span class="hljs-string">&quot;-.-.&quot;</span>,<span class="hljs-string">&quot;-..&quot;</span>,<span class="hljs-string">&quot;.&quot;</span>,<span class="hljs-string">&quot;..-.&quot;</span>,<span class="hljs-string">&quot;--.&quot;</span>,<br>                         <span class="hljs-string">&quot;....&quot;</span>,<span class="hljs-string">&quot;..&quot;</span>,<span class="hljs-string">&quot;.---&quot;</span>,<span class="hljs-string">&quot;-.-&quot;</span>,<span class="hljs-string">&quot;.-..&quot;</span>,<span class="hljs-string">&quot;--&quot;</span>,<span class="hljs-string">&quot;-.&quot;</span>,<br>                         <span class="hljs-string">&quot;---&quot;</span>,<span class="hljs-string">&quot;.--.&quot;</span>,<span class="hljs-string">&quot;--.-&quot;</span>,<span class="hljs-string">&quot;.-.&quot;</span>,<span class="hljs-string">&quot;...&quot;</span>,<span class="hljs-string">&quot;-&quot;</span>,<span class="hljs-string">&quot;..-&quot;</span>,<br>                         <span class="hljs-string">&quot;...-&quot;</span>,<span class="hljs-string">&quot;.--&quot;</span>,<span class="hljs-string">&quot;-..-&quot;</span>,<span class="hljs-string">&quot;-.--&quot;</span>,<span class="hljs-string">&quot;--..&quot;</span>&#125;;<br><br>        Set&lt;String&gt; seen = <span class="hljs-keyword">new</span> HashSet();<br>        <span class="hljs-keyword">for</span> (String word: words) &#123;<br>            StringBuilder code = <span class="hljs-keyword">new</span> StringBuilder();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c: word.toCharArray())<br>                code.append(MORSE[c - <span class="hljs-string">&#x27;a&#x27;</span>]);<br>            seen.add(code.toString());<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> seen.size();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：$O(S)$ ，其中 $S$ 是数组 words 中所有单词的长度之和。</li><li>空间复杂度：$O(S)$。</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>709-转换成小写字母</title>
    <link href="/2020/12/05/LeetCode-709%E8%BD%AC%E6%8D%A2%E6%88%90%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D/"/>
    <url>/2020/12/05/LeetCode-709%E8%BD%AC%E6%8D%A2%E6%88%90%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-709转换成小写字母"><a href="#LeetCode-709转换成小写字母" class="headerlink" title="LeetCode-709转换成小写字母"></a>LeetCode-709转换成小写字母</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>实现函数 ToLowerCase()，该函数接收一个字符串参数 str，并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。</strong></p><p><strong>示例 1：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lsl">输入：<span class="hljs-string">&quot;Hello&quot;</span><br>输出：<span class="hljs-string">&quot;hello&quot;</span><br></code></pre></div></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lsl">输入：<span class="hljs-string">&quot;here&quot;</span><br>输出：<span class="hljs-string">&quot;here&quot;</span><br></code></pre></div></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lsl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lsl">输入：<span class="hljs-string">&quot;LOVELY&quot;</span><br>输出：<span class="hljs-string">&quot;lovely&quot;</span><br></code></pre></div></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="方法一：ASCCII-码"><a href="#方法一：ASCCII-码" class="headerlink" title="方法一：ASCCII 码"></a>方法一：ASCCII 码</h3><p><strong>思路及解法</strong></p><p>通过 $ASCCII$ 码表操作字符串即可。</p><p><strong>代码1</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toLowerCase</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span> || str.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> str;<br>        &#125;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> ch : str.toCharArray()) &#123;<br>            <span class="hljs-comment">// a-z：97-122  A-Z：65-90  0-9：48-57</span><br>            <span class="hljs-keyword">if</span> (ch &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) &#123;<br>                sb.append((<span class="hljs-keyword">char</span>)(ch + <span class="hljs-number">32</span>));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sb.append(ch);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>代码2</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toLowerCase</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span> || str.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> str;<br>        &#125;<br>        <span class="hljs-keyword">char</span>[] ch = str.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (ch[i] &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; ch[i] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) &#123;<br>                ch[i] += <span class="hljs-number">32</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> String.valueOf(ch);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="方法二：位运算"><a href="#方法二：位运算" class="headerlink" title="方法二：位运算"></a>方法二：位运算</h3><p><strong>思路及解法</strong></p><p>用位运算的技巧：</p><ol><li><strong>大写变小写、小写变大写：字符 ^= 32；</strong></li><li><strong>大写变小写、小写变小写：字符 |= 32；</strong></li><li><strong>大写变大写、小写变大写：字符 &amp;= 33。</strong></li></ol><p>ASCCII 码表中大写的 A 是65，小写的 a 是97，他们的差是 32；</p><p>65 | 32 转为二进制（按 8 位来算）可以得到 0100 0001 | 0010 0000 = 0110 0001 = 97 = a​</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toLowerCase</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span> || str.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> str;<br>        &#125;<br>        <span class="hljs-keyword">char</span>[] ch = str.toCharArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>            ch[i] |= <span class="hljs-number">32</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> String.valueOf(ch);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>283-移动零</title>
    <link href="/2020/12/04/LeetCode-283%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
    <url>/2020/12/04/LeetCode-283%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-283移动零"><a href="#LeetCode-283移动零" class="headerlink" title="LeetCode-283移动零"></a>LeetCode-283移动零</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>给定一个数组 nums，编写一个函数将所有的 0 移动到数组的末尾，同时保持非零元素的相对顺序。</strong></p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[0, 1, 0, 3, 12]</span><br>输出：<span class="hljs-string">[1, 3, 12, 0, 0]</span><br></code></pre></div></td></tr></table></figure><p><strong>说明：</strong></p><ol><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ol><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="方法一：双指针"><a href="#方法一：双指针" class="headerlink" title="方法一：双指针"></a>方法一：双指针</h3><p><strong>思路及解法</strong></p><p>使用双指针，左指针指向当前已经处理好的序列的尾部，右指针只想待处理序列的头部。</p><p>右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。</p><p>注意到以下性质：</p><ol><li><strong>左指针左边均为非零数；</strong></li><li><strong>右指针左边到左指针处均为零。</strong></li></ol><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length, left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (nums[right] != <span class="hljs-number">0</span>) &#123;<br>                swap(nums, left, right);<br>                left++;<br>            &#125;<br>            right++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> temp = nums[left];<br>        nums[left] = nums[right];<br>        nums[right] = temp;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：$O(n)$ ，其中 $n$ 是序列长度。每个位置至多被遍历两次。</li><li>空间复杂度：$O(1)$。只需要常数的空间存放若干变量。</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1486-数组异或操作</title>
    <link href="/2020/12/03/LeetCode-1486%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/12/03/LeetCode-1486%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-1486数组异或操作"><a href="#LeetCode-1486数组异或操作" class="headerlink" title="LeetCode-1486数组异或操作"></a>LeetCode-1486数组异或操作</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>给定两个整数， $n$ 和 $start$。</strong></p><p>数组 $nums$ 定义为：$nums[i] = start + 2 * i$ （下标从 $0$ 开始）且 $n == nums.length$。</p><p>请返回 $nums$ 中所有元素按位异或（<strong>XOR</strong>）后得到的结果。</p><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">5</span>, start = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">8</span><br>解释：数组 nums 为 [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>], 其中 (<span class="hljs-number">0</span> ^ <span class="hljs-number">2</span> ^ <span class="hljs-number">4</span> ^ <span class="hljs-number">6</span> ^ <span class="hljs-number">8</span>) = <span class="hljs-number">8</span>。 <span class="hljs-string">&quot;^&quot;</span> 为按位或 <span class="hljs-built_in">XOR</span> 运算符<br></code></pre></div></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">4</span>, <span class="hljs-attr">start</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">8</span><br>解释：数组 nums 为 [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>]，其中 (<span class="hljs-number">3</span> ^ <span class="hljs-number">5</span> ^ <span class="hljs-number">7</span> ^ <span class="hljs-number">9</span>) = <span class="hljs-number">8</span><br></code></pre></div></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">1</span>, <span class="hljs-attr">start</span> = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">7</span><br></code></pre></div></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">10</span>, <span class="hljs-attr">start</span> = <span class="hljs-number">5</span><br>输出：<span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>$1 &lt;= n &lt;= 1000$</li><li>$0 &lt;= start &lt;= 1000$</li><li>$n == nums.length$</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;统计 $[2, n]$ 中质数的数量是一个很常见的题目，也有很多巧妙高效的做法，接下来的部分只会讲述一些常见的做法，更多的拓展内容读者可以自行搜索补充，也欢迎在评论区与大家分享交流。</p><h3 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h3><p><strong>思路：</strong></p><p>按照题意模拟即可：</p><ul><li>初始化 $ans = 0$</li><li>遍历区间 $[0, n - 1]$ 中的每一个整数 $i$，令 $ans$ 与每一个 $\rm start + 2 \times i$ 做异或运算</li><li>最终返回 $ans$ ，即我们需要的答案</li></ul><p><strong>代码展示：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">xorOperation</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> start)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            ans ^= (start + i * <span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：$O(n)$ 。这里用一重循环对 $n$ 个数字进行异或。</li><li>空间复杂度：$O(1)$。这里只是用了常量级别的辅助空间。</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>204-计算质数</title>
    <link href="/2020/12/02/LeetCode-204%E8%AE%A1%E7%AE%97%E8%B4%A8%E6%95%B0/"/>
    <url>/2020/12/02/LeetCode-204%E8%AE%A1%E7%AE%97%E8%B4%A8%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-204计算质数"><a href="#LeetCode-204计算质数" class="headerlink" title="LeetCode-204计算质数"></a>LeetCode-204计算质数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>统计所有小于非负整数 $n$ 的质数的数量</strong></p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dns">输入：n = <span class="hljs-number">10</span><br>输出：<span class="hljs-number">4</span><br>解释：小于 <span class="hljs-number">10</span> 的质数一共有<span class="hljs-number">4</span>个，它们是 <span class="hljs-number">2，3，5，7</span><br></code></pre></div></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p><strong>提示：</strong></p><p>$0 &lt;= n &lt;= 5 \times 10^6$</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;统计 $[2, n]$ 中质数的数量是一个很常见的题目，也有很多巧妙高效的做法，接下来的部分只会讲述一些常见的做法，更多的拓展内容读者可以自行搜索补充，也欢迎在评论区与大家分享交流。</p><h3 id="方法一：枚举"><a href="#方法一：枚举" class="headerlink" title="方法一：枚举"></a>方法一：枚举</h3><p>&emsp;&emsp;很直观的思路是我们枚举每个数判断其是不是质数。</p><p>&emsp;&emsp;考虑质数的定义：在大于 $1$ 的自然数中，除了 $1$ 和它本身以外不再有其他因数的自然数。因此对于每个数 $x$，我们可以从小到大枚举 $[2, x -1]$ 中的每个数 $y$，判断 y 是否为 $x$ 的因数。但这样判断一个数是否为质数的时间复杂度最差情况下会到 $O(n)$，无法通过所有的测试数据。</p><p>&emsp;&emsp;考虑到如果 y 是 $x$ 的因数，那么 $\frac{x}{y}$ 也必然是 $x$ 的因数，因此我们只要校验 $y$ 或者 $\frac{x}{y}$ 即可。而如果我们每次选择校验两者中的较小数，则不难发现较小数一定落在 $[2, \sqrt{x}]$ 的区间中，因此我们只要枚举 $[2, \sqrt{x}]$ 中的所有数即可，这样单次检查的时间复杂度从 $O(n)$ 降低至了 $O(\sqrt{x})$ 。</p><p><strong>代码展示：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; ++i) &#123;<br>            ans += isPrime(i) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= x; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：$O(n\sqrt{n})$ 。单个数检查的时间复杂度为 $O(\sqrt{n})$，一共要检查 $O(\sqrt{n})$ 个数，因此总时间复杂为 $O(n\sqrt{n})$。</li><li>空间复杂度：$O(1)$。</li></ul><h3 id="方法二：埃氏筛"><a href="#方法二：埃氏筛" class="headerlink" title="方法二：埃氏筛"></a>方法二：埃氏筛</h3><p>&emsp;&emsp;枚举没有考虑到数与数的关联性，因此难以再继续优化时间复杂度。接下来我们介绍一个常见的算法，该算法由希腊数学家厄拉多塞 $(\rm EratosthenesEratosthenes)$ 提出，称为厄拉多塞筛法，简称埃氏筛。</p><p>&emsp;&emsp;我们考虑这样一个事实：如果 $x$ 是质数，那么大于 $x$ 的 $x$ 的倍数 $2x, 3x,\ldots$ 一定不是质数，因此我们可以从这里入手。</p><p>&emsp;&emsp;我们设 $\text{isPrime[i]}$ 表示数 $i$ 是不是质数，如果是质数则为 $1$，否则为 $0$。从小到大遍历每个数，如果这个数为质数，则将其所有的倍数都标记为合数（除了该质数本身），即 $0$，这样在运行结束的时候我们即能知道质数的个数。</p><p>&emsp;&emsp;这种方法的正确性是比较显然的：这种方法显然不会将质数标记成合数；另一方面，当从小到大遍历到数 $x$ 时，倘若它是合数，则它一定是某个小于 $x$ 的质数 $y$ 的整数倍，故根据此方法的步骤，我们在遍历到 $y$ 时，就一定会在此时将 $x$ 标记为 $\text{isPrime}[x]=0$。因此，这种方法也不会将合数标记为质数。</p><p>&emsp;&emsp;当然这里还可以继续优化，对于一个质数 $x$，如果按上文说的我们从 $2x$ 开始标记其实是冗余的，应该直接<strong>从</strong> $x\cdot x$ <strong>开始标记</strong>，因为 $2x,3x,\ldots$ 这些数一定在 $x$ 之前就被其他数的倍数标记过了，例如 $2$ 的所有倍数，$3$ 的所有倍数等。</p><p><strong>代码展示：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] isPrime = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        Arrays.fill(isPrime, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (isPrime[i] == <span class="hljs-number">1</span>) &#123;<br>                ans += <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">long</span>) i * i &lt; n) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i * i; j &lt; n; j += i) &#123;<br>                        isPrime[j] = <span class="hljs-number">0</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>复杂度 分析：</strong></p><ul><li>时间复杂度：$O(n \log \log n)$ 。</li><li>空间复杂度：$O(n)$。我们需要 $O(n)$ 的空间记录每个数是否为质数。</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>136-只出现一次的数字</title>
    <link href="/2020/12/01/LeetCode-136%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2020/12/01/LeetCode-136%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-136只出现一次的数字"><a href="#LeetCode-136只出现一次的数字" class="headerlink" title="LeetCode-136只出现一次的数字"></a>LeetCode-136只出现一次的数字</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次，找出那个只出现一次的元素</strong></p><p><strong>示例 1：</strong></p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[2, 2, 1]</span><br>输出：1<br></code></pre></div></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[4, 1, 2, 1, 2]</span><br>输出：<span class="hljs-number">4</span><br></code></pre></div></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight excel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p><strong>说明：</strong></p><p><strong>你的算法应该具有线性时间复杂度。你可以不使用额外空间来实现吗？</strong></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="方法一：位运算"><a href="#方法一：位运算" class="headerlink" title="方法一：位运算"></a>方法一：位运算</h3><p>如果没有时间复杂度和空间复杂度的限制，这道题有很多解法，可能的解法有以下几种：</p><ul><li>使用集合存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字。</li><li>使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。</li><li>使用集合存储数组中出现的所有数字，并计算数组中的元素之和。由于集合保证元素不重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的就是数组中只出现一次的数字。</li></ul><p>上述三种解法都需要额外使用 $O(n)$ 的空间。其中 $n$ 是数组长度。如果要求使用线性时间复杂度和常数空间复杂度，上述三种解法显然都不满足要求。那么，如何才能做到线性时间复杂度和常数空间复杂度呢？</p><p>答案是使用<strong>位运算</strong>。对于这道题，可使用异或运算 $\oplus$。异或运算有一下三个性质。</p><ul><li>任何数和 $0$ 做异或运算，结果仍然是原来的数，即 $a \oplus 0 = a$ 。</li><li>任何数和自身做异或运算，结果是 $0$，即 $a \oplus a = 0$ 。</li><li>异或运算满足交换律和结合律，即 $a \oplus b \oplus a=b \oplus a \oplus a=b \oplus (a \oplus a)=b \oplus0=b$。</li></ul><p>假设数组有 $2m + 1$ 个数，其中有 $m$ 个数各出现两次，一个数出现一次。令 $a_{1}、a{2}、\ldots、a{m}$ 为出现两次的 $m$ 个数，$a_{m+1}$ 为出现一次的数。根据性质 $3$，数组中的全部元素的异或运算结果总是可以写成如下形式：</p><p>&emsp;&emsp;$(a_{1} \oplus a_{1}) \oplus (a_{2} \oplus a_{2}) \oplus \cdots \oplus (a_{m} \oplus a_{m}) \oplus a_{m+1}$</p><p>根据性质 $2$ 和性质 $1$，上式可简化和计算<strong>得到如下结果</strong>：</p><p>&emsp;&emsp;$0 \oplus 0 \oplus \cdots \oplus 0 \oplus a_{m+1} = a_{m+1}$</p><p><strong>因此，数组中的全部元素的异或运算结果即为数组中只出现一次的数字。</strong></p><p><strong>代码展示：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> single = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>            single ^= num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> single;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：$O(n)$ ，其中 $n$ 是数组的长度。只需要对数组遍历一次。</li><li>空间复杂度：$O(1)$。</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker部署springboot项目</title>
    <link href="/2020/12/01/docker%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/"/>
    <url>/2020/12/01/docker%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="docker部署springboot项目"><a href="#docker部署springboot项目" class="headerlink" title="docker部署springboot项目"></a>docker部署springboot项目</h1><h2 id="1-项目打包，注意：打包的时候-pom-xml-要有下列配置"><a href="#1-项目打包，注意：打包的时候-pom-xml-要有下列配置" class="headerlink" title="1. 项目打包，注意：打包的时候 pom.xml 要有下列配置"></a><strong>1. 项目打包，注意：打包的时候 pom.xml 要有下列配置</strong></h2>   <figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 加入下面两项配置 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>repackage<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">includeSystemScope</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">includeSystemScope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="2-编写-Dockerfile-文件"><a href="#2-编写-Dockerfile-文件" class="headerlink" title="2. 编写 Dockerfile 文件"></a><strong>2. 编写 Dockerfile 文件</strong></h2>   <figure class="highlight dockerfile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-comment"># Docker image for springboot file run</span><br><span class="hljs-comment"># VERSION 0.0.1</span><br><span class="hljs-comment"># Author: eangulee</span><br><span class="hljs-comment"># 基础镜像使用java</span><br><span class="hljs-keyword">FROM</span> java:<span class="hljs-number">8</span><br><span class="hljs-comment"># 作者</span><br><span class="hljs-keyword">MAINTAINER</span> hzlei &lt;hzlei@foxmail.com&gt;<br><span class="hljs-comment"># VOLUME 指定了临时文件目录为 /tmp。</span><br><span class="hljs-comment"># 其效果是在主机 /var/lib/docker 目录下创建了一个临时文件，并链接到容器的 /tmp</span><br><span class="hljs-keyword">VOLUME</span><span class="bash"> /tmp</span><br><span class="hljs-comment"># 将jar包添加到容器中并更名为app.jar</span><br><span class="hljs-keyword">ADD</span><span class="bash"> demo-1.0-SNAPSHOT.jar app.jar</span><br><span class="hljs-comment"># 声明需要暴露的端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8848</span><br><span class="hljs-comment"># 运行jar包</span><br><span class="hljs-keyword">RUN</span><span class="bash"> bash -c <span class="hljs-string">&#x27;touch /app.jar&#x27;</span></span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-Djava.security.egd=file:/dev/./urandom&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;/app.jar&quot;</span>]</span><br></code></pre></div></td></tr></table></figure><p>   Dockerfile 文件说明</p>   <figure class="highlight dockerfile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> 基础镜像，当前镜像是基于哪个镜像的<br>MANINTAINER 镜像维护者的姓名和邮箱地址<br><span class="hljs-keyword">VOLUME</span><span class="bash"> 容器数据卷，用于数据保存和持久化工作，也可以叫缓存目录吧</span><br><span class="hljs-keyword">ADD</span><span class="bash"> 将宿主机目录下的文件拷贝进镜像且 ADD 命令会自动处理 URL 和解压 tar 压缩包</span><br><span class="hljs-keyword">EXPOSE</span> 当前容器对外暴露出的端口<br><span class="hljs-keyword">RUN</span><span class="bash"> 容器构造时需要运行的命令</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> 指定一个容器启动时要运行的命令。ENTRYPOINT 的目的和 CMD 命令一样，都是在指定容器启动程序及参数</span><br><span class="hljs-keyword">CMD</span><span class="bash"> 指定一个容器启动时要运行的命令。Dockerfile 可以有多个 CMD 指令，但只要最后一个生效，CMD会被docker run 之后的参数替换</span><br></code></pre></div></td></tr></table></figure><h2 id="3-将-Dockerfile-文件和打包后的-jar-包，放到服务器的同一文件夹下"><a href="#3-将-Dockerfile-文件和打包后的-jar-包，放到服务器的同一文件夹下" class="headerlink" title="3. 将 Dockerfile 文件和打包后的 jar 包，放到服务器的同一文件夹下"></a><strong>3. 将 Dockerfile 文件和打包后的 jar 包，放到服务器的同一文件夹下</strong></h2><h2 id="4-创建镜像"><a href="#4-创建镜像" class="headerlink" title="4. 创建镜像"></a><strong>4. 创建镜像</strong></h2>   <figure class="highlight dockerfile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dockerfile">docker build -t docker-test .<br></code></pre></div></td></tr></table></figure>   <figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-comment"># 参数说明</span><br>-t表示将新镜像命名为 docker-test<br>.末尾的 . 指明 <span class="hljs-keyword">build </span><span class="hljs-built_in">context</span> 为当前目录<br>Docker 默认会从 <span class="hljs-keyword">build </span><span class="hljs-built_in">context</span> 中查找 Dockerfile 文件，我们也可以通过 -f 参数指定 Dockerfile 位置<br></code></pre></div></td></tr></table></figure><h2 id="5-镜像创建完毕之后，可通过-docker-images-查看创建好的镜像"><a href="#5-镜像创建完毕之后，可通过-docker-images-查看创建好的镜像" class="headerlink" title="5. 镜像创建完毕之后，可通过 docker images 查看创建好的镜像"></a><strong>5. 镜像创建完毕之后，可通过 docker images 查看创建好的镜像</strong></h2><h2 id="6-运行镜像"><a href="#6-运行镜像" class="headerlink" title="6. 运行镜像"></a><strong>6. 运行镜像</strong></h2>   <figure class="highlight dockerfile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dockerfile">docker <span class="hljs-keyword">run</span><span class="bash"> -d -p 8848:8848 docker-test</span><br></code></pre></div></td></tr></table></figure>   <figure class="highlight dockerfile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 参数说明</span><br><span class="hljs-keyword">run</span><span class="bash">运行镜像</span><br>-d让容器后台运行<br>-p做端口映射，将服务器中的 <span class="hljs-number">8848</span> 端口映射进容器中的 <span class="hljs-number">8848</span>(项目中配置的是<span class="hljs-number">8848</span>)端口<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>项目部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CentOS</tag>
      
      <tag>DocKer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>命令合集</title>
    <link href="/2020/08/13/%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/"/>
    <url>/2020/08/13/%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><h5 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h5><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> （change directory：英文释义是改变目录）切换目录<br><br><span class="hljs-keyword">cd</span> <span class="hljs-string">../</span> ;跳到上级目录<br><span class="hljs-keyword">cd</span> <span class="hljs-string">/opt</span> ;不管现在到那直接跳到指定的opt文件夹中<br><span class="hljs-keyword">cd</span> ~ ;切换当前用户的家目录。root用户的家目录就是root目录。<br>复制代码<br></code></pre></div></td></tr></table></figure><h5 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h5><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">pwd</span> （<span class="hljs-keyword">print</span> working directory：显示当前工作目录的绝对路径）<br><br><span class="hljs-keyword">pwd</span> <br>显示当前的绝对路劲<br>复制代码<br></code></pre></div></td></tr></table></figure><h5 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h5><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">ls</span> （<span class="hljs-keyword">ls</span>：list的缩写，查看列表）查看当前目录下的所有文件夹（<span class="hljs-keyword">ls</span> 只列出文件名或目录名）<br><br><span class="hljs-keyword">ls</span> -a ;显示所有文件夹,隐藏文件也显示出来<br><span class="hljs-keyword">ls</span> -R ;连同子目录一起列出来<br></code></pre></div></td></tr></table></figure><h5 id="ll"><a href="#ll" class="headerlink" title="ll"></a>ll</h5><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">ll </span>（<span class="hljs-keyword">ll：list的缩写，查看列表详情）查看当前目录下的所有详细信息和文件夹（ll </span>结果是详细,有时间,是否可读写等信息）<br><br><span class="hljs-keyword">ll </span>-a <span class="hljs-comment">;显示所有文件,隐藏文件也显示出来</span><br><span class="hljs-keyword">ll </span>-R <span class="hljs-comment">;连同子目录内容一起列出来</span><br><span class="hljs-keyword">ll </span>-h <span class="hljs-comment">;友好展示详情信息,可以看大小</span><br><span class="hljs-keyword">ll </span>-al <span class="hljs-comment">;即能显示隐藏文件又能显示详细列表。 </span><br>复制代码<br></code></pre></div></td></tr></table></figure><h5 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h5><figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata">touch （touch：创建文件）创建文件<br><br>touch <span class="hljs-keyword">test</span>.txt  ;创建<span class="hljs-keyword">test</span>.txt文件<br>touch /opt/java/<span class="hljs-keyword">test</span>.java ;在指定目录创建<span class="hljs-keyword">test</span>.java文件<br>复制代码<br></code></pre></div></td></tr></table></figure><h5 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h5><figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata"><span class="hljs-keyword">mkdir</span> （<span class="hljs-keyword">mkdir</span>：创建目录） 创建目录<br><br><span class="hljs-keyword">mkdir</span> 文件夹名称 ;在此目录创建文件夹<br><span class="hljs-keyword">mkdir</span> /opt/java/jdk ;在指定目录创建文件夹<br></code></pre></div></td></tr></table></figure><h5 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h5><figure class="highlight llvm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs llvm">cat （concatenate：显示或把多个文本文件连接起来）查看文件命令（可以快捷查看当前文件的内容）（不能快速定位到最后一页）<br><br>cat lj.log <span class="hljs-comment">;快捷查看文件命令 </span><br>Ctrl + <span class="hljs-keyword">c</span> <span class="hljs-comment">;暂停显示文件</span><br>Ctrl + d <span class="hljs-comment">;退出查看文件命令</span><br>复制代码<br></code></pre></div></td></tr></table></figure><h5 id="more"><a href="#more" class="headerlink" title="more"></a>more</h5><figure class="highlight dos"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dos"><span class="hljs-built_in">more</span> （<span class="hljs-built_in">more</span>：更多的意思）分页查看文件命令（不能快速定位到最后一页）<br><br>回车：向下n行，需要定义，默认为<span class="hljs-number">1</span>行。<br>空格键：向下滚动一屏或Ctrl+F<br>B：返回上一层或Ctrl+B<br>q：退出<span class="hljs-built_in">more</span><br>复制代码<br></code></pre></div></td></tr></table></figure><h5 id="less"><a href="#less" class="headerlink" title="less"></a>less</h5><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake"><span class="hljs-keyword">less</span> （lese：较少的意思）分页查看文件命令（可以快速定位到最后一页）<br><br><span class="hljs-keyword">less</span> -m 显示类似于more命令的百分比。<br><span class="hljs-keyword">less</span> -N 显示每行的行号。(大写的N)<br>两参数一起使用如：<span class="hljs-keyword">less</span> -mN 文件名，如此可分页并显示行号。<br><br>空格键：前下一页或page down。<br>回车：向下一行。<br>b：后退一页 或 page up。<br>q：退出。<br>d：前进半页。<br>u：后退半页<br></code></pre></div></td></tr></table></figure><h5 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h5><figure class="highlight llvm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs llvm"><span class="hljs-keyword">tail</span>（尾巴） 查看文件命令（看最后多少行）<br><br><span class="hljs-keyword">tail</span> <span class="hljs-number">-10</span> <span class="hljs-comment">;文件名 看最后10行</span><br>复制代码<br></code></pre></div></td></tr></table></figure><h5 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h5><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle">cp（<span class="hljs-keyword">copy</span>单词缩写，复制功能）<br><br>cp <span class="hljs-regexp">/opt/</span>java<span class="hljs-regexp">/java.log /</span>opt<span class="hljs-regexp">/logs/</span> ;把java.log 复制到<span class="hljs-regexp">/opt/</span>logs/下<br>cp <span class="hljs-regexp">/opt/</span>java<span class="hljs-regexp">/java.log /</span>opt<span class="hljs-regexp">/logs/</span>aaa.log ;把java.log 复制到<span class="hljs-regexp">/opt/</span>logs/下并且改名为aaa.log<br>cp -r <span class="hljs-regexp">/opt/</span>java <span class="hljs-regexp">/opt/</span>logs ;把文件夹及内容复制到logs文件中<br>复制代码<br></code></pre></div></td></tr></table></figure><h5 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h5><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino">mv（<span class="hljs-built_in">move</span>单词缩写，移动功能，该文件名称功能）<br><br>mv /opt/java/java.<span class="hljs-built_in">log</span> /opt/mysql/ ;移动文件到mysql目录下<br>mv java.<span class="hljs-built_in">log</span> mysql.<span class="hljs-built_in">log</span> ;把java.<span class="hljs-built_in">log</span>改名为mysql.<span class="hljs-built_in">log</span><br></code></pre></div></td></tr></table></figure><h5 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h5><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-built_in">rm</span>（remove：移除的意思）删除文件，或文件夹<br><br><span class="hljs-operator">-f</span>或-<span class="hljs-literal">-force</span> 强制删除文件或目录。删除文件不包括文件夹的文件<br><span class="hljs-literal">-r</span>或<span class="hljs-literal">-R</span>或-<span class="hljs-literal">-recursive</span> 递归处理，将指定目录下的所有文件及子目录一并删除。 <br><span class="hljs-literal">-rf</span> 强制删除文件夹及内容<br><br><span class="hljs-built_in">rm</span> 文件名 ;安全删除命令  （yes删除 no取消）<br><span class="hljs-built_in">rm</span> <span class="hljs-literal">-rf</span> 强制删除文件夹及内容<br><span class="hljs-built_in">rm</span> <span class="hljs-literal">-rf</span> *  删除当前目录下的所有内容。<br><span class="hljs-built_in">rm</span> <span class="hljs-literal">-rf</span> /* 删除Linux系统根目录下所有的内容。系统将完蛋。   <br>复制代码<br></code></pre></div></td></tr></table></figure><h5 id="find"><a href="#find" class="headerlink" title="find"></a>find</h5><figure class="highlight sqf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sqf"><span class="hljs-built_in">find</span> （<span class="hljs-built_in">find</span>：找到的意思）查找指定文件或目录<br><br>* 表示<span class="hljs-number">0</span>~多个任意字符。<br><br><span class="hljs-built_in">find</span> -<span class="hljs-built_in">name</span> 文件名;按照指定名称查找在当前目录下查找文件<br><span class="hljs-built_in">find</span> / -<span class="hljs-built_in">name</span> 文件名按照指定名称全局查找文件<br><span class="hljs-built_in">find</span> -<span class="hljs-built_in">name</span> <span class="hljs-string">&#x27;*文件名&#x27;</span> ;任意前缀加上文件名在当前目录下查找文件<br><span class="hljs-built_in">find</span> / -<span class="hljs-built_in">name</span> <span class="hljs-string">&#x27;*文件名*&#x27;</span> ;全局进行模糊查询带文件名的文件 <br></code></pre></div></td></tr></table></figure><h5 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h5><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">vi</span> （VIsual：视觉）文本编辑器  类似win的记事本 （操作类似于地下的<span class="hljs-keyword">vim</span>命令，看底下<span class="hljs-keyword">vim</span> 的操作）<br></code></pre></div></td></tr></table></figure><h5 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h5><figure class="highlight llvm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs llvm">vim （VI IMproved：改进版视觉）改进版文本编辑器 （不管是文件查看还是文件编辑 按 Shift + 上或者下可以上下移动查看视角）<br><br>输入”vim 文件名” 打开文件，刚刚时是”一般模式”。<br><br>一般模式：可以浏览文件内容，可以进行文本快捷操作。如单行复制，多行复制，单行删除，多行删除，（退出）等。<br>插入模式：可以编辑文件内容。<br>底行模式：可以进行强制退出操作<span class="hljs-punctuation">,</span>不保存   :q!<br> 可以进行保存并退出操作       :wq<br><br>按下”i”或”a”或”o”键，从”一般模式”，进入”插入模式（编辑模式）”。<br>在编辑模式下按”Esc” 即可到一般模式<br>在一般模式下按”:”，冒号进入底行模式。<br><br>在一般模式下的快捷键<br>dd <span class="hljs-comment">;删除一整行</span><br>X <span class="hljs-comment">;向前删除  等同于windowns系统中的删除键</span><br><span class="hljs-keyword">x</span> <span class="hljs-comment">;向后删除和大写x相反方向</span><br>Ctrl + f <span class="hljs-comment">;向后看一页</span><br>Ctrl + b <span class="hljs-comment">;向前看一页</span><br>u <span class="hljs-comment">;撤销上一步操作</span><br>/word <span class="hljs-comment">;向下查找word关键字  输入:n查找下一个,N查找上一个（不管是哪个查找都是全局查找 只不过n的方向相反）</span><br>?log <span class="hljs-comment">;向上查找log关键字  输入:n查找上一个,N查找下一个</span><br>:<span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">90</span>s/redis/Redis/g <span class="hljs-comment">;把1-90行的redis替换为Redis。语法n1,n2s/原关键字/新关键字/g，n1代表其实行,n2代表结尾行,g是必须要的</span><br>:<span class="hljs-number">0</span> <span class="hljs-comment">;光标移动到第一行</span><br>:$ <span class="hljs-comment">;光标移动到最后一行</span><br>:<span class="hljs-number">300</span> <span class="hljs-comment">;光标移动到300行,输入多少数字移动到多少行</span><br>:w  <span class="hljs-comment">;保存</span><br>:w! <span class="hljs-comment">;强制保存</span><br>:q  <span class="hljs-comment">;退出</span><br>:q! <span class="hljs-comment">;强制退出</span><br><span class="hljs-number">5</span>dd <span class="hljs-comment">;删除后面5行,打一个参数为自己填写</span><br><span class="hljs-number">5</span><span class="hljs-keyword">x</span> <span class="hljs-comment">;删除此光标后面5个字符</span><br>d<span class="hljs-number">1</span>G <span class="hljs-comment">;删除此光标之前的所有</span><br>d<span class="hljs-number">0</span> <span class="hljs-comment">;从光标当前位置删除到此行的第一个位置</span><br>yy <span class="hljs-comment">;复制</span><br>p <span class="hljs-comment">;在光标的下面进行粘贴</span><br>P <span class="hljs-comment">;在光标的上门进行粘贴</span><br></code></pre></div></td></tr></table></figure><h5 id=""><a href="#" class="headerlink" title="|"></a>|</h5><figure class="highlight coq"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coq">| <span class="hljs-type">管道命令（把多个命令组合起来使用）</span><br><span class="hljs-type"></span><br><span class="hljs-type">管道命令的语法：命令1</span> | <span class="hljs-type">命令2</span> | <span class="hljs-type">命令3</span>。<br>复制代码<br></code></pre></div></td></tr></table></figure><h5 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h5><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">grep</span> （<span class="hljs-keyword">grep</span> ：正则表达式）正则表达式，用于字符串的搜索工作(模糊查询)。不懂可以先过<br><br>单独使用：<br><span class="hljs-keyword">grep</span> String test.java ；在test.java文件中查找String的位置，返回整行<br>一般此命令不会单独使用下面列几个常用的命令（地下通过管道命令组合起来使用）<br><br><span class="hljs-keyword">ps</span> aux|<span class="hljs-keyword">grep</span> java ；查找带java关键字的进程<br><span class="hljs-keyword">ll</span> |<span class="hljs-keyword">grep</span> java ；查找带java关键字的文件夹及文件<br></code></pre></div></td></tr></table></figure><h5 id="yum-install-y-lrzsz"><a href="#yum-install-y-lrzsz" class="headerlink" title="yum install -y lrzsz"></a>yum install -y lrzsz</h5><figure class="highlight vala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vala">yum install -y lrzsz 命令（实现win到Linux文件互相简单上传文件）<br><br><span class="hljs-meta">#（实际上就是在Linux系统中下载了一个插件）下了了此安装包后就可以实现win系统到linux之间拉文件拉文件</span><br><span class="hljs-meta">#等待下载完了就可以输入：</span><br><br>rz  从win系统中选择文件上传到Linux系统中<br><br>sz  文件名 选择Linux系统的文件复制到win系统中<br><br>复制代码<br></code></pre></div></td></tr></table></figure><h5 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">tar</span> （解压  压缩  命令）<br><br>常用的组合命令：<br><span class="hljs-selector-tag">-z</span> 是否需要用<span class="hljs-selector-tag">gzip</span>压缩。<br><span class="hljs-selector-tag">-c</span> 建立一个压缩文件的参数指令(<span class="hljs-selector-tag">create</span>) –压缩<br><span class="hljs-selector-tag">-x</span> 解开一个压缩文件的参数指令(<span class="hljs-selector-tag">extract</span>) –解压  <br><span class="hljs-selector-tag">-v</span> 压缩的过程中显示文件(<span class="hljs-selector-tag">verbose</span>)<br><span class="hljs-selector-tag">-f</span> 使用档名，在<span class="hljs-selector-tag">f</span>之后要立即接档中(<span class="hljs-selector-tag">file</span>)<br>常用解压参数组合：<span class="hljs-selector-tag">zxvf</span><br>常用压缩参数组合：<span class="hljs-selector-tag">zcvf</span> <br><br>解压命令：<br><span class="hljs-selector-tag">tar</span> <span class="hljs-selector-tag">-zxvf</span> <span class="hljs-selector-tag">redis-3</span>.2.8<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> ；解压到当前文件夹<br><span class="hljs-selector-tag">tar</span> <span class="hljs-selector-tag">-zxvf</span> <span class="hljs-selector-tag">redis-3</span>.2.8<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> <span class="hljs-selector-tag">-C</span> /<span class="hljs-selector-tag">opt</span>/<span class="hljs-selector-tag">java</span>/ ；解压到指定目录<br><br>压缩命令：（注意 语法有点反了，我反正每次都搞反）<br><span class="hljs-selector-tag">tar</span> <span class="hljs-selector-tag">-zcvf</span> <span class="hljs-selector-tag">redis-3</span>.2.8<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span>  <span class="hljs-selector-tag">redis-3</span>.2.8/  ;语法 <span class="hljs-selector-tag">tar</span> <span class="hljs-selector-tag">-zcvf</span>  压缩后的名称  要压缩的文件<br><span class="hljs-selector-tag">tar</span> <span class="hljs-selector-tag">-zcvf</span> 压缩后的文件（可指定目录）  要压缩的文件（可指定目录） <br></code></pre></div></td></tr></table></figure><h5 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h5><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">ps （process status：进程状态，类似于windows的任务管理器）<br><br>常用组合：ps -ef     标准的格式查看系统进程<br>  ps -aux    BSD格式查看系统进程<br>  ps -aux|grep redis  BSD格式查看进程名称带有redis的系统进程（常用技巧）<br><span class="hljs-regexp">//</span>显示进程的一些属性,需要了解（ps aux）<br>USER     <span class="hljs-regexp">//</span>用户名<br>PID <span class="hljs-regexp">//</span>进程ID号,用来杀死进程的<br>%CPU     <span class="hljs-regexp">//</span>进程占用的CPU的百分比<br>%MEM     <span class="hljs-regexp">//</span>占用内存的的百分比<br>VSZ      <span class="hljs-regexp">//</span>该进程使用的虚拟內存量（KB）<br>RSS      <span class="hljs-regexp">//</span>该进程占用的固定內存量（KB）<br>STAT     <span class="hljs-regexp">//</span>进程的状态<br>START    <span class="hljs-regexp">//</span>该进程被触发启动时间<br>TIME     <span class="hljs-regexp">//</span>该进程实际使用CPU运行的时间<br>复制代码<br></code></pre></div></td></tr></table></figure><h5 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h5><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-built_in">clear</span>  清屏命令。（强迫症患者使用）<br><br><span class="hljs-built_in">kill</span> 命令用来中止一个进程。（要配合<span class="hljs-built_in">ps</span>命令使用，配合pid关闭进程）<br>（<span class="hljs-built_in">ps</span>类似于打开任务管理器，<span class="hljs-built_in">kill</span>类似于关闭进程）<br><span class="hljs-built_in">kill</span> <span class="hljs-literal">-5</span> 进程的PID ;推荐,和平关闭进程<br><span class="hljs-built_in">kill</span> <span class="hljs-literal">-9</span> PID ;不推荐,强制杀死进程<br></code></pre></div></td></tr></table></figure><h5 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h5><figure class="highlight armasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">ifconfig</span>命令<br><br>用于查看和更改网络接口的地址和参数，包括<span class="hljs-built_in">IP</span>地址、网络掩码、广播地址，使用权限是超级用户。（一般是用来查看的，很少更改）<br>如果此命令输入无效，先输入yum -y install net-tools<br><span class="hljs-symbol">ifconfig</span><br>复制代码<br></code></pre></div></td></tr></table></figure><h5 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h5><figure class="highlight dos"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dos"><span class="hljs-built_in">ping</span> （用于检测与目标的连通性）语法：<span class="hljs-built_in">ping</span> ip地址<br><br>测试：<br><span class="hljs-number">1</span>、在Windows操作系统中<span class="hljs-built_in">cmd</span><span class="hljs-built_in">ipconfig</span>，查看本机IP地址：<br><span class="hljs-number">2</span>、再到LInux系统中输入 <span class="hljs-built_in">ping</span> ip地址<br>（公司电脑，我就不暴露Ip了,没图片  自己去试）<br>按Ctrl + C 可以停止测试。<br></code></pre></div></td></tr></table></figure><h5 id="free"><a href="#free" class="headerlink" title="free"></a>free</h5><figure class="highlight diff"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs diff">free 命令 （显示系统内存）<br><br>#显示系统内存使用情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。<br><span class="hljs-deletion">-b 以Byte显示内存使用情况</span><br><span class="hljs-deletion">-k 以kb为单位显示内存使用情况</span><br><span class="hljs-deletion">-m 以mb为单位显示内存使用情况</span><br><span class="hljs-deletion">-g 以gb为单位显示内存使用情况</span><br><span class="hljs-deletion">-s&lt;间隔秒数&gt; 持续显示内存</span><br><span class="hljs-deletion">-t 显示内存使用总合</span><br>复制代码<br></code></pre></div></td></tr></table></figure><h5 id="top"><a href="#top" class="headerlink" title="top"></a>top</h5><figure class="highlight diff"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs diff">top 命令<br><br>#显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等<br><span class="hljs-deletion">-c 显示完整的进程命令</span><br><span class="hljs-deletion">-s 保密模式</span><br><span class="hljs-deletion">-p &lt;进程号&gt; 指定进程显示</span><br><span class="hljs-deletion">-n &lt;次数&gt;循环显示次数</span><br>复制代码<br></code></pre></div></td></tr></table></figure><h5 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h5><figure class="highlight vala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vala">netstat 命令<br><br><span class="hljs-meta">#Linux netstat命令用于显示网络状态。</span><br><span class="hljs-meta">#利用netstat指令可让你得知整个Linux系统的网络情况。</span><br><span class="hljs-meta">#语法：</span><br>netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][--ip]<br></code></pre></div></td></tr></table></figure><h5 id="file"><a href="#file" class="headerlink" title="file"></a>file</h5><figure class="highlight livecodeserver"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">file</span> （可查看文件类型）<br><br><span class="hljs-built_in">file</span> 文件名<br>复制代码<br></code></pre></div></td></tr></table></figure><h5 id="重启linux"><a href="#重启linux" class="headerlink" title="重启linux"></a>重启linux</h5><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">Linux</span> centos 重启命令：reboot<br>复制代码<br></code></pre></div></td></tr></table></figure><h5 id="关机linux"><a href="#关机linux" class="headerlink" title="关机linux"></a>关机linux</h5><figure class="highlight cos"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cos">Linux centos 关机命令：<span class="hljs-keyword">halt</span><br><br>复制代码<br></code></pre></div></td></tr></table></figure><h5 id="同步时间命令"><a href="#同步时间命令" class="headerlink" title="同步时间命令"></a>同步时间命令</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">ntpdate</span> <span class="hljs-selector-tag">ntp1</span><span class="hljs-selector-class">.aliyun</span><span class="hljs-selector-class">.com</span><br>复制代码<br></code></pre></div></td></tr></table></figure><h5 id="更改为北京时间命令"><a href="#更改为北京时间命令" class="headerlink" title="更改为北京时间命令"></a>更改为北京时间命令</h5><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle">rm -rf <span class="hljs-regexp">/etc/</span>localtime<br>ln -s <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/zoneinfo/</span>Asia<span class="hljs-regexp">/Shanghai /</span>etc/localtime<br></code></pre></div></td></tr></table></figure><h5 id="查看时间命令："><a href="#查看时间命令：" class="headerlink" title="查看时间命令："></a>查看时间命令：</h5><figure class="highlight lasso"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs lasso"><span class="hljs-built_in">date</span><br></code></pre></div></td></tr></table></figure><h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1>]]></content>
    
    
    <categories>
      
      <category>linux命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-选择排序</title>
    <link href="/2020/07/22/Java-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/07/22/Java-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-选择排序（时间复杂度为O-n²-）"><a href="#Java-选择排序（时间复杂度为O-n²-）" class="headerlink" title="Java-选择排序（时间复杂度为O(n²) ）"></a>Java-选择排序（时间复杂度为O(n²) ）</h1><h2 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h2><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p><h2 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h2><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/selectionSort.gif" alt="选择排序"></p><h2 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectionSort</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">44</span>, <span class="hljs-number">38</span>, <span class="hljs-number">5</span>, <span class="hljs-number">47</span>, <span class="hljs-number">15</span>, <span class="hljs-number">36</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>, <span class="hljs-number">2</span>, <span class="hljs-number">46</span>, <span class="hljs-number">4</span>, <span class="hljs-number">19</span>, <span class="hljs-number">50</span>, <span class="hljs-number">48</span>&#125;;<br><br>        selectionSort(arr);<br><br>        System.out.println(Arrays.toString(arr));<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 选择排序：前一个与后面逐个进行比较，将最小的放到前面</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr 待排序的数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-comment">// 最小值的索引，默认是前面元素</span><br>            <span class="hljs-keyword">int</span> minIndex = i;<br>            <span class="hljs-comment">// 最小值，默认是前面元素</span><br>            <span class="hljs-keyword">int</span> minValue = arr[i];<br><br>            <span class="hljs-comment">// 与后面的元素进行比较</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123;<br>                <span class="hljs-comment">// 比较大小，得到最小的值、下标</span><br>                <span class="hljs-keyword">if</span> (minValue &gt; arr[j])&#123;<br>                    minIndex = j;<br>                    minValue = arr[j];<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 如果最小值不是默认的元素则交换</span><br>            <span class="hljs-keyword">if</span> (minIndex != i)&#123;<br>                arr[minIndex] = arr[i];<br>                arr[i] = minValue;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-插入排序</title>
    <link href="/2020/07/22/Java-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/07/22/Java-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-插入排序（复杂度为O-n2-）"><a href="#Java-插入排序（复杂度为O-n2-）" class="headerlink" title="Java-插入排序（复杂度为O(n2) ）"></a>Java-插入排序（复杂度为O(n2) ）</h1><h2 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h2><p>插入排序是一种最简单的排序方法，它的基本思想是从数组中逐个元素作为插入元素，和前面的进行比较，小的即插入前面。</p><h2 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h2><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/insertionSort.gif" alt="插入排序"></p><h2 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InsertSort</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">44</span>, <span class="hljs-number">38</span>, <span class="hljs-number">5</span>, <span class="hljs-number">47</span>, <span class="hljs-number">15</span>, <span class="hljs-number">36</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>, <span class="hljs-number">2</span>, <span class="hljs-number">46</span>, <span class="hljs-number">4</span>, <span class="hljs-number">19</span>, <span class="hljs-number">50</span>, <span class="hljs-number">48</span>&#125;;<br><br>        insertSort(arr);<br><br>        System.out.println(Arrays.toString(arr));<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 插入排序：从数组中逐个元素作为插入元素，和前面的进行比较，小的即插入前面。</span><br><span class="hljs-comment">     * 前面的已经是排完序的了。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr 待排序的数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-comment">// 插入的下标，默认是前一位</span><br>            <span class="hljs-keyword">int</span> insertIndex = i - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 插入的值</span><br>            <span class="hljs-keyword">int</span> insertValue = arr[i];<br>            <span class="hljs-comment">// 插入的值和前面的进行比较，小则插入。排序：从小到大，改大于号则排序为从大到小</span><br>            <span class="hljs-keyword">while</span> (insertIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; insertValue &lt; arr[insertIndex])&#123;<br>                <span class="hljs-comment">// 交换，将小的放前面，保证前面是已经排序后的</span><br>                arr[insertIndex + <span class="hljs-number">1</span>] = arr[insertIndex];<br>                insertIndex --;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(insertIndex != i - <span class="hljs-number">1</span>) &#123;<br>                arr[insertIndex + <span class="hljs-number">1</span>] = insertValue;<br>            &#125;<br><br>            System.out.println(<span class="hljs-string">&quot;第&quot;</span> + i + <span class="hljs-string">&quot;轮：&quot;</span> + Arrays.toString(arr));<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud底层服务之间是怎样互相调用的</title>
    <link href="/2020/07/20/SpringCloud%E5%BA%95%E5%B1%82%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E6%98%AF%E6%80%8E%E6%A0%B7%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8%E7%9A%84/"/>
    <url>/2020/07/20/SpringCloud%E5%BA%95%E5%B1%82%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E6%98%AF%E6%80%8E%E6%A0%B7%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringCloud底层服务之间是怎样互相调用的"><a href="#SpringCloud底层服务之间是怎样互相调用的" class="headerlink" title="SpringCloud底层服务之间是怎样互相调用的 ?"></a>SpringCloud底层服务之间是怎样互相调用的 ?</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>毫无疑问，Spring Cloud是目前微服务架构领域的翘楚，无数的书籍博客都在讲解这个技术。不过大多数讲解还停留在对Spring Cloud功能使用的层面，其底层的很多原理，很多人可能并不知晓。<strong>因此本文将通过大量的手绘图</strong>，给大家谈谈Spring Cloud微服务架构的底层原理。</p><p>实际上，Spring Cloud是一个全家桶式的技术栈，包含了很多组件。本文先从其最核心的几个组件入手，来剖析一下其底层的工作原理。也就是<strong>Eureka、Ribbon、Feign、Hystrix、Zuul这几个组件</strong>。</p><h1 id="一，业务场景介绍"><a href="#一，业务场景介绍" class="headerlink" title="一，业务场景介绍"></a>一，业务场景介绍</h1><p>先来给大家说一个业务场景，假设咱们现在开发一个电商网站，要实现支付订单的功能，流程如下：</p><ul><li>创建一个订单之后，如果用户立刻支付了这个订单，我们需要将订单状态更新为“已支付”</li><li>扣减相应的商品库存</li><li>通知仓储中心，进行发货</li><li>给用户的这次购物增加相应的积分<br></li></ul><p>针对上述流程，<strong>我们需要有订单服务、库存服务、仓储服务、积分服务</strong>。整个流程的大体思路如下：</p><ul><li>用户针对一个订单完成支付之后，就会去找订单服务，更新订单状态</li><li>订单服务调用库存服务，完成相应功能</li><li>订单服务调用仓储服务，完成相应功能</li><li>订单服务调用积分服务，完成相应功能<br></li></ul><p><strong>至此，整个支付订单的业务流程结束</strong><br><br><br>下图这张图，清晰表明了各服务间的调用过程：<br><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/SpringCloud%E5%BA%95%E5%B1%82%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8%E7%9A%84-1.png" alt="SpringCloud底层服务之间是怎么相互调用的"><br>好！有了业务场景之后，咱们就一起来看看Spring Cloud微服务架构中，这几个组件如何相互协作，各自发挥的作用以及其背后的原理。</p><h1 id="二，Eureka，服务发现组件"><a href="#二，Eureka，服务发现组件" class="headerlink" title="二，Eureka，服务发现组件"></a>二，Eureka，服务发现组件</h1><p><strong>咱们来考虑第一个问题</strong>：订单服务想要调用库存服务、仓储服务，或者是积分服务，怎么调用？</p><ul><li><p>订单服务压根儿就不知道人家库存服务在哪台机器上啊！他就算想要发起一个请求，都不知道发送给谁，有心无力！</p></li><li><p>这时候，就轮到Spring Cloud Eureka出场了。Eureka是微服务架构中的注册中心，专门负责服务的注册与发现。</p><p>咱们来看看下面的这张图，结合图来仔细剖析一下整个流程：<br><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/SpringCloud%E5%BA%95%E5%B1%82%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8%E7%9A%84-2.png" alt="SpringCloud底层服务之间是怎么相互调用的"><br>如上图所示，库存服务、仓储服务、积分服务中都有一个Eureka Client组件，这个组件专门负责将这个服务的信息注册到Eureka Server中。说白了，就是告诉Eureka Server，自己在哪台机器上，监听着哪个端口。而Eureka Server是一个注册中心，里面有一个注册表，保存了各服务所在的机器和端口号。</p><br>订单服务里也有一个Eureka Client组件，这个Eureka Client组件会找Eureka Server问一下：库存服务在哪台机器啊？监听着哪个端口啊？仓储服务呢？积分服务呢？然后就可以把这些相关信息从Eureka Server的注册表中拉取到自己本地缓存起来。<br>这时如果订单服务想要调用库存服务，不就可以找自己本地的Eureka Client问一下库存服务在哪台机器？监听哪个端口吗？收到响应后，紧接着就可以发送一个请求过去，调用库存服务扣减库存的那个接口！同理，如果订单服务要调用仓储服务、积分服务，也是如法炮制。<br></li></ul><p><strong>总结一下</strong>：</p><ul><li>Eureka Client：负责将这个服务的信息注册到Eureka Server中。</li><li>Eureka Server：注册中心，里面有一个注册表，保存了各个服务所在的机器和端口号。</li></ul><h1 id="三，Feign，动态代理"><a href="#三，Feign，动态代理" class="headerlink" title="三，Feign，动态代理"></a>三，Feign，动态代理</h1><p>现在订单服务确实知道库存服务、积分服务、仓库服务在哪里了，同时也监听着哪些端口号了。<strong>但是新问题又来了：难道订单服务要自己写一大堆代码，跟其他服务建立网络连接，然后构造一个复杂的请求，接着发送请求过去，最后对返回的响应结果再写一大堆代码来处理吗</strong>？<br><br><br>这是上述流程翻译的代码片段，咱们一起来看看，体会一下这种绝望而无助的感受！！！<br><br><br><strong>友情提示，前方高能</strong>：<br><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/SpringCloud%E5%BA%95%E5%B1%82%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8%E7%9A%84-3.png" alt="SpringCloud底层服务之间是怎么相互调用的"><br>看完上面那一大段代码，有没有感到后背发凉、一身冷汗？实际上你进行服务间调用时，如果每次都手写代码，代码量比上面那段要多至少几倍，所以这个事儿压根儿就不是地球人能干的。<br><br><br>既然如此，那怎么办呢？别急，Feign早已为我们提供好了优雅的解决方案。来看看如果用Feign的话，你的订单服务调用库存服务的代码会变成啥样？<br><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/SpringCloud%E5%BA%95%E5%B1%82%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8%E7%9A%84-4.png" alt="SpringCloud底层服务之间是怎么相互调用的"><br>看完上面的代码什么感觉？是不是感觉整个世界都干净了，又找到了活下去的勇气！没有底层的建立连接、构造请求、解析响应的代码，直接就是用注解定义一个 FeignClient接口，然后调用那个接口就可以了。人家Feign Client会在底层根据你的注解，跟你指定的服务建立连接、构造请求、发起靕求、获取响应、解析响应，等等。这一系列脏活累活，人家Feign全给你干了。<br><br><br>那么问题来了，Feign是如何做到这么神奇的呢？很简单，<strong>Feign的一个关键机制就是使用了动态代理</strong>。咱们一起来看看下面的图，结合图来分析：</p><ul><li>首先，如果你对某个接口定义了@FeignClient注解，Feign就会针对这个接口创建一个动态代理。</li><li>接着你要是调用那个接口，本质就是会调用 Feign创建的动态代理，这是核心中的核心。</li><li>Feign的动态代理会根据你在接口上的@RequestMapping等注解，来动态构造出你要请求的服务的地址。</li><li>最后针对这个地址，发起请求、解析响应。<br><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/SpringCloud%E5%BA%95%E5%B1%82%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8%E7%9A%84-5.png" alt="SpringCloud底层服务之间是怎么相互调用的"></li></ul><h1 id="四、Ribbon，负载均衡"><a href="#四、Ribbon，负载均衡" class="headerlink" title="四、Ribbon，负载均衡"></a>四、Ribbon，负载均衡</h1><p>说完了Feign，还没完。现在新的问题又来了，如果人家库存服务部署在了5台机器上，如下所示：</p><ul><li>192.168.169:9000</li><li>192.168.170:9000</li><li>192.168.171:9000</li><li>192.168.172:9000</li><li>192.168.173:9000<br></li></ul><p><strong>这下麻烦了！人家Feign怎么知道该请求哪台机器呢</strong>？</p><ul><li>这时Spring Cloud Ribbon就派上用场了。Ribbon就是专门解决这个问题的。它的作用是负载均衡，会帮你在每次请求时选择一台机器，均匀的把请求分发到各个机器上。</li><li>Ribbon的负载均衡默认使用的最经典的Round Robin轮询算法。这是啥？简单来说，就是如果订单服务对库存服务发起10次请求，那就先让你请求第1台机器、然后是第2台机器、第3台机器、第4台机器、第5台机器，接着再来—个循环，第1台机器、第2台机器。。。以此类推。<br></li></ul><p><strong>此外，Ribbon是和Feign以及Eureka紧密协作，完成工作的，具体如下</strong>：</p><ul><li>首先Ribbon会从 Eureka Client里获取到对应的服务注册表，也就知道了所有的服务都部署在了哪些机器上，在监听哪些端口号。</li><li>然后Ribbon就可以使用默认的Round Robin算法，从中选择一台机器</li><li>Feign就会针对这台机器，构造并发起请求。</li></ul><br>对上述整个过程，再来一张图，帮助大家更深刻的理解：<p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/SpringCloud%E5%BA%95%E5%B1%82%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8%E7%9A%84-6.png" alt="SpringCloud底层服务之间是怎么相互调用的"></p><h1 id="五、Hystrix，熔断，隔离和降级"><a href="#五、Hystrix，熔断，隔离和降级" class="headerlink" title="五、Hystrix，熔断，隔离和降级"></a>五、Hystrix，熔断，隔离和降级</h1><p>在微服务架构里，一个系统会有很多的服务。以本文的业务场景为例：订单服务在一个业务流程里需要调用三个服务。现在假设订单服务自己最多只有100个线程可以处理请求，然后呢，积分服务不幸的挂了，每次订单服务调用积分服务的时候，都会卡住几秒钟，然后抛出—个超时异常。<br><br></p><p><strong>咱们一起来分析一下，这样会导致什么问题</strong>？</p><ul><li>如果系统处于高并发的场景下，大量请求涌过来的时候，订单服务的100个线程都会卡在请求积分服务这块。导致订单服务没有一个线程可以处理请求。</li><li>然后就会导致别人请求订单服务的时候，发现订单服务也挂了，不响应任何请求了。<br></li></ul><p>上面这个，就是<strong>微服务架构中恐怖的服务雪崩问题</strong>，如下图所示：<br><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/SpringCloud%E5%BA%95%E5%B1%82%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8%E7%9A%84-7.png" alt="SpringCloud底层服务之间是怎么相互调用的"><br>如上图，这么多服务互相调用，要是不做任何保护的话，某一个服务挂了，就会引起连锁反应，导致别的服务也挂。比如积分服务挂了，会导致订单服务的线程全部卡在请求积分服务这里，没有一个线程可以工作，瞬间导致订单服务也挂了，别人请求订单服务全部会卡住，无法响应。<br><br><br></p><p><strong>但是我们思考一下，就算积分服务挂了，订单服务也可以不用挂啊！为什么</strong>？</p><ul><li>我们结合业务来看：支付订单的时候，只要把库存扣减了，然后通知仓库发货就OK了</li><li>如果积分服务挂了，大不了等他恢复之后，慢慢人肉手工恢复数据！为啥一定要因为一个积分服务挂了，就直接导致订单服务也挂了呢？不可以接受！<br><br><br></li></ul><p><strong>现在问题分析完了，如何解决</strong>？</p><p>这时就轮到Hystrix闪亮登场了。Hystrix是隔离、熔断以及降级的一个框架。啥意思呢？说白了，Hystrix会搞很多个小小的线程池，比如订单服务请求库存服务是一个线程池，请求仓储服务是一个线程池，请求积分服务是一个线程池。每个线程池里的线程就仅仅用于请求那个服务。<br><br><br><br><strong>打个比方：现在很不幸，积分服务挂了，会咋样</strong>？</p><p>当然会导致订单服务里的那个用来调用积分服务的线程都卡死不能工作了啊！但是由于订单服务调用库存服务、仓储服务的这两个线程池都是正常工作的，所以这两个服务不会受到任何影响。<br><br><br><br>这个时候如果别人请求订单服务，订单服务还是可以正常调用库存服务扣减库存，调用仓储服务通知发货。只不过调用积分服务的时候，每次都会报错。<strong>但是如果积分服务都挂了，每次调用都要去卡住几秒钟干啥呢？有意义吗？当然没有</strong>！所以我们直接对积分服务熔断不就得了，比如在5分钟内请求积分服务直接就返回了，不要去走网络请求卡住几秒钟，这个过程，就是所谓的熔断！<br><br><br><br><strong>那人家又说，兄弟，积分服务挂了你就熔断，好歹你干点儿什么啊</strong>！别啥都不干就直接返回啊？没问题，咱们就来个降级：每次调用积分服务，你就在数据库里记录一条消息，说给某某用户增加了多少积分，因为积分服务挂了，导致没增加成功！这样等积分服务恢复了，你可以根据这些记录手工加一下积分。这个过程，就是所谓的降级。<br><br><br><br>为帮助大家更直观的理解，接下来用一张图，梳理一下Hystrix隔离、熔断和降级的全流程：<br><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/SpringCloud%E5%BA%95%E5%B1%82%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8%E7%9A%84-8.png" alt="SpringCloud底层服务之间是怎么相互调用的"></p><h1 id="六、Zuul，网关"><a href="#六、Zuul，网关" class="headerlink" title="六、Zuul，网关"></a>六、Zuul，网关</h1><p>说完了Hystrix，接着给大家说说最后一个组件：Zuul，也就是微服务网关。这个组件是负责网络路由的。不懂网络路由？行，那我给你说说，如果没有Zuul的日常工作会怎样？<br><br><br>假设你后台部署了几百个服务，现在有个前端兄弟，人家请求是直接从浏览器那儿发过来的。<strong>打个比方</strong>：人家要请求一下库存服务，你难道还让人家记着这服务的名字叫做inventory-service？部署在5台机器上？就算人家肯记住这一个，你后台可有几百个服务的名称和地址呢？难不成人家请求一个，就得记住一个？你要这样玩儿，那真是友谊的小船，说翻就翻！<br><br><br>上面这种情况，压根儿是不现实的。所以一般微服务架构中都必然会设计一个网关在里面，像android、ios、pc前端、微信小程序、H5等等，不用去关心后端有几百个服务，就知道有一个网关，所有请求都往网关走，网关会根据请求中的一些特征，将请求转发给后端的各个服务。<br><br><br>而且有一个网关之后，还有很多好处，比如可以做统一的降级、限流、认证授权、安全，等等。</p><h1 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h1><p>最后再来总结一下，上述几个Spring Cloud核心组件，在微服务架构中，分别扮演的角色：</p><ul><li><p><strong>Eureka（服务发现组件）</strong>：各个服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉取注册表，从而知道其他服务在哪里。</p></li><li><p><strong>Ribbon（负载均衡）</strong>：服务间发起请求的时候，基于Ribbon做负载均衡，从一个服务的多台机器中选择一台。</p></li><li><p><strong>Feign（动态代理）</strong>：基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求。</p></li><li><p><strong>Hystrix（熔断，隔离和降级）</strong>：发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。</p></li><li><p><strong>Zuul（网关）</strong>：如果前端、移动端要调用后端系统，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务。</p></li></ul><br><p>以上就是我们通过一个电商业务场景，阐述了Spring Cloud微服务架构几个核心组件的底层原理。<br><br><br></p><p><strong>文字总结还不够直观？没问题</strong>！我们将Spring Cloud的5个核心组件通过一张图串联起来，再来直观的感受一下其底层的架构原理：<br><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/SpringCloud%E5%BA%95%E5%B1%82%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8%E7%9A%84-9.png" alt="SpringCloud底层服务之间是怎么相互调用的"></p>]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-快速排序</title>
    <link href="/2020/07/20/Java-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/07/20/Java-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-快速排序（时间复杂度：O-N-logN-）"><a href="#Java-快速排序（时间复杂度：O-N-logN-）" class="headerlink" title="Java-快速排序（时间复杂度：O(N*logN) ）"></a>Java-快速排序（时间复杂度：O(N*logN) ）</h1><h2 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h2><p>快速排序由C. A. R. Hoare在1960年提出。</p><p>它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序。</p><p>它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。</p><p>最坏运行情况是 O(n²)</p><h2 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h2><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/quickSort.gif" alt="快速排序"></p><h2 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickSort</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">44</span>, <span class="hljs-number">38</span>, <span class="hljs-number">5</span>, <span class="hljs-number">47</span>, <span class="hljs-number">15</span>, <span class="hljs-number">36</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>, <span class="hljs-number">2</span>, <span class="hljs-number">46</span>, <span class="hljs-number">4</span>, <span class="hljs-number">19</span>, <span class="hljs-number">50</span>, <span class="hljs-number">48</span>&#125;;<br><br>quickSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br><br>System.out.println(Arrays.toString(arr));<br><br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 传入 3 个参数</span><br><span class="hljs-comment"> * 1, 数组 arr</span><br><span class="hljs-comment"> * 2, 排序开始的位置, 左边 left</span><br><span class="hljs-comment"> * 3, 排序结束的位置, 右边 right</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br><span class="hljs-comment">// 进行判断, 如果左边索引比右边索引大, 不合法, 直接用 return 结束这个方法</span><br><span class="hljs-keyword">if</span> (left &gt; right) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// 定义变量保存基准数</span><br><span class="hljs-keyword">int</span> base = arr[left];<br><span class="hljs-comment">// 定义变量 i, 指向最左边</span><br><span class="hljs-keyword">int</span> i = left;<br><span class="hljs-comment">// 定义变量 j, 指向最右边</span><br><span class="hljs-keyword">int</span> j = right;<br><br><span class="hljs-comment">// 当 i 和 j 不相遇的时候, 在循环中进行检索</span><br><span class="hljs-keyword">while</span> (i != j) &#123;<br><span class="hljs-comment">// 先由 j 从右往左检索比基准数小的, 如果检索到比基准数小的, 就停下</span><br><span class="hljs-comment">// 如果检索到比基准数大的或者相等的, 就继续检索</span><br><span class="hljs-keyword">while</span> (arr[j] &gt;= base &amp;&amp; i &lt; j) &#123;<br>j--;<span class="hljs-comment">// j从右往左移动</span><br>&#125;<br><br><span class="hljs-comment">// i 从左往右检索</span><br><span class="hljs-keyword">while</span> (arr[i] &lt;= base &amp;&amp; i &lt; j) &#123;<br>i++;<span class="hljs-comment">// i 从左往右移动</span><br>&#125;<br><br><span class="hljs-comment">// 代码走到这里, i 和 j 都停下了, 然后交换 i 和 j 的位置的元素</span><br><span class="hljs-keyword">int</span> temp = arr[i];<br>arr[i] = arr[j];<br>arr[j] = temp;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 如果上面 while 循环的条件不成立, 会跳出循环, 往下执行</span><br><span class="hljs-comment"> * 如果这个条件不成立, 说明 i 和 j 相遇了</span><br><span class="hljs-comment"> * 如果 i 和 j 相遇了, 就交换基准数这个元素和相遇位置的元素</span><br><span class="hljs-comment"> * 把相遇位置的元素赋值给基准数这个位置的元素</span><br><span class="hljs-comment"> */</span><br>arr[left] = arr[i];<br><br><span class="hljs-comment">// 把基准数赋值给相遇位置的元素</span><br>arr[i] = base;<br><br><span class="hljs-comment">// 基准数在这里就归位了, 左边的数字比他小, 右边的数字比他大</span><br><br><span class="hljs-comment">// 然后排基准数的左边</span><br>quickSort(arr, left, i - <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 然后排基准数的右边</span><br>quickSort(arr, j + <span class="hljs-number">1</span>, right);<br>&#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>window下MySQL8.0.19安装教程</title>
    <link href="/2020/07/20/window%E4%B8%8BMySQL8.0.19%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <url>/2020/07/20/window%E4%B8%8BMySQL8.0.19%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="window下MySQL8-0-19安装教程"><a href="#window下MySQL8-0-19安装教程" class="headerlink" title="window下MySQL8.0.19安装教程"></a>window下MySQL8.0.19安装教程</h1><p>下载MySQL</p><p>官网下载地址:</p><p><a href="https://dev.mysql.com/downloads/mysql/">mysql下载</a></p><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/window%E4%B8%8BMySQL8.0.19%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B-1.png" alt="官网下载界面"></p><p>下载完之后解压到本地:</p><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/window%E4%B8%8BMySQL8.0.19%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B-2.png" alt="解压后的样子"></p><p>在本目录下新建my.ini文件, 并写入基本配置, 我的是创建过的</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">[mysqld]<br># 设置<span class="hljs-number">3306</span>端口<br>port<span class="hljs-operator">=</span><span class="hljs-number">3306</span><br># 设置mysql的安装目录<br>basedir<span class="hljs-operator">=</span>D:\mysql<span class="hljs-number">-8.0</span><span class="hljs-number">.19</span><br># 设置mysql数据库的数据的存放目录(此目录会在之后进行命令生成，无需手写)<br>datadir<span class="hljs-operator">=</span>D:\mysql<span class="hljs-number">-8.0</span><span class="hljs-number">.19</span>\data<br># 允许最大连接数<br>max_connections<span class="hljs-operator">=</span><span class="hljs-number">200</span><br># 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统<br>max_connect_errors<span class="hljs-operator">=</span><span class="hljs-number">10</span><br># 服务端使用的字符集默认为UTF8<br><span class="hljs-type">character</span><span class="hljs-operator">-</span><span class="hljs-keyword">set</span><span class="hljs-operator">-</span>server<span class="hljs-operator">=</span>utf8<br># 创建新表时将使用的默认存储引擎<br><span class="hljs-keyword">default</span><span class="hljs-operator">-</span>storage<span class="hljs-operator">-</span>engine<span class="hljs-operator">=</span>INNODB<br># 默认使用“mysql_native_password”插件认证<br>default_authentication_plugin<span class="hljs-operator">=</span>mysql_native_password<br>[mysql]<br># 设置mysql客户端默认字符集<br><span class="hljs-keyword">default</span><span class="hljs-operator">-</span><span class="hljs-type">character</span><span class="hljs-operator">-</span><span class="hljs-keyword">set</span><span class="hljs-operator">=</span>utf8<br>[client]<br># 设置mysql客户端连接服务端时默认使用的端口<br>port<span class="hljs-operator">=</span><span class="hljs-number">3306</span><br><span class="hljs-keyword">default</span><span class="hljs-operator">-</span><span class="hljs-type">character</span><span class="hljs-operator">-</span><span class="hljs-keyword">set</span><span class="hljs-operator">=</span>utf8<br><br></code></pre></div></td></tr></table></figure><p><strong>设置的安装目录要与解压后的目录保持一致</strong></p><p>然后开始安装:</p><p><strong>以管理员方式打开命令提示符</strong></p><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/window%E4%B8%8BMySQL8.0.19%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B-3.png" alt="以管理员方式打开命令提示符"></p><p><strong>进入bin目录</strong><br><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/window%E4%B8%8BMySQL8.0.19%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B-4.png" alt="进入bin目录"></p><blockquote><p>在bin目录下执行:<br><strong>mysqld –initialize –console</strong></p></blockquote><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/window%E4%B8%8BMySQL8.0.19%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B-5.png" alt="在这里插入图片描述"></p><p>如若出现此提示(没有出现忽略此步骤): 需要安装下面这个</p><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/window%E4%B8%8BMySQL8.0.19%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B-6.png" alt="在这里插入图片描述"></p><p><a href="https://pan.baidu.com/s/1tfMpNTnb6Fv_HZY9DybHFQ">某pan</a></p><p>提取码: <strong>gk1a</strong></p><p>执行完<strong>mysqld –initialize –console</strong>是这样:<br><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/window%E4%B8%8BMySQL8.0.19%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B-7.png" alt="在这里插入图片描述"></p><p><strong>记号密码, 下面要用</strong></p><blockquote><p>root@localhost: dKc&amp;OEoRq6tR<br><strong>root: 为账号</strong><br><strong>dKc&amp;OEoRq6tR: 为初始密码</strong></p><hr><p>然后安装MySQL:<br><strong>mysqld –install</strong></p></blockquote><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/window%E4%B8%8BMySQL8.0.19%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B-8.png" alt="启动成功"></p><p>如果出现这种情况:<br><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/window%E4%B8%8BMySQL8.0.19%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B-9.png" alt="在这里插入图片描述"></p><blockquote><p>需要先把mysql的服务删掉<br>命令:<br>s<strong>c delete mysql</strong></p></blockquote><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/window%E4%B8%8BMySQL8.0.19%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B-10.png" alt="在这里插入图片描述"></p><blockquote><p>然后再去执行: mysqld –install</p><hr><p>安装成功之后, 启动MySQL服务<br>命令:<br><strong>net start mysql</strong></p></blockquote><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/window%E4%B8%8BMySQL8.0.19%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B-11.png" alt="在这里插入图片描述"></p><blockquote><p>然后测试连接MySQL<br>可以用 Nacicat, 小海豚…等工具进行测试<br>我这里用的 Navicat</p></blockquote><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/window%E4%B8%8BMySQL8.0.19%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B-12.png" alt="在这里插入图片描述"></p><blockquote><p>新建MySQL连接<br>账户密码为开始时的账户和初始密码</p></blockquote><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/window%E4%B8%8BMySQL8.0.19%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B-13.png" alt="在这里插入图片描述"></p><blockquote><p>连接成功之后<br>可进行密码修改<br>密码修改可以用命令修改<br><strong>alter user ‘root’@’localhost’ identified by ‘newPassword’</strong></p><hr><p> 我这里用 Navicat 登录之后就提示让修改密码了, 哈哈<br> 安装到此就结束了.</p></blockquote><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/window%E4%B8%8BMySQL8.0.19%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B-14.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>软件安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS下Docker安装步骤</title>
    <link href="/2020/07/20/CentOS%E4%B8%8BDocker%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/"/>
    <url>/2020/07/20/CentOS%E4%B8%8BDocker%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="CentOS下Docker安装步骤"><a href="#CentOS下Docker安装步骤" class="headerlink" title="CentOS下Docker安装步骤"></a>CentOS下Docker安装步骤</h1><p><strong>1. Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。</strong> </p><blockquote><p>查看当前内核版本<br>uname -r</p></blockquote><p><strong>2. root 权限下 更新 yum 包</strong></p><blockquote><p>sudo yum update</p></blockquote><p><strong>3. 卸载旧版本</strong></p><blockquote><p>sudo yum remove docker docker-common docker-selinux docker-engine</p></blockquote><p><strong>4. 安装需要的软件包，yum-util 提供 yum-config-manager 功能，另外两个是 devicemapper 驱动依赖的</strong></p><blockquote><p>sudo yum install -y yum-utils device-mapper-perisistent-data lvm2</p></blockquote><p><strong>5. 设置 yum 源</strong></p><blockquote><p>sudo yum-config-manager –add-repo <a href="https://download.docker.com/linux/centos/docker-ce.repo">https://download.docker.com/linux/centos/docker-ce.repo</a></p></blockquote><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/CentOS%E4%B8%8BDocker%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4-1.png" alt="设置yum源"></p><p><strong>6. 可以查看所有仓库中所有 docker 版本，选择合适版本安装</strong></p><blockquote><p>yum list docker-ce –showduplicates | sort -r</p></blockquote><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/CentOS%E4%B8%8BDocker%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4-2.png" alt="查看docker版本"></p><p><strong>7. 安装 docker，我这里安装的是 18.03.1 版本</strong></p><blockquote><p>sudo yum install docker-ce-18.03.1.ce</p></blockquote><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/CentOS%E4%B8%8BDocker%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4-3.png" alt="安装docker"></p><p><strong>8. 启动并加入开机自启</strong></p><blockquote><p>sudo systemctl start docker<br>sudo systemctl enable docker</p></blockquote><p><strong>9. 验证安装时候成功，有 client 和 service 两部分表示 docker 安装启动都成功了</strong></p><blockquote><p>docker version</p></blockquote><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/CentOS%E4%B8%8BDocker%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4-4.png" alt="验证安装时候成功"></p>]]></content>
    
    
    <categories>
      
      <category>软件安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CentOS</tag>
      
      <tag>DocKer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决国内Git官网下载太慢的方法</title>
    <link href="/2020/07/20/%E8%A7%A3%E5%86%B3%E5%9B%BD%E5%86%85Git%E5%AE%98%E7%BD%91%E4%B8%8B%E8%BD%BD%E5%A4%AA%E6%85%A2%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2020/07/20/%E8%A7%A3%E5%86%B3%E5%9B%BD%E5%86%85Git%E5%AE%98%E7%BD%91%E4%B8%8B%E8%BD%BD%E5%A4%AA%E6%85%A2%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="解决国内Git官网下载太慢的方法"><a href="#解决国内Git官网下载太慢的方法" class="headerlink" title="解决国内Git官网下载太慢的方法"></a>解决国内Git官网下载太慢的方法</h1><h2 id="淘宝有一个镜像网站，可以在这上面下载，历史版本和新版本都有"><a href="#淘宝有一个镜像网站，可以在这上面下载，历史版本和新版本都有" class="headerlink" title="淘宝有一个镜像网站，可以在这上面下载，历史版本和新版本都有"></a>淘宝有一个镜像网站，可以在这上面下载，历史版本和新版本都有</h2><p>地址：<a href="https://npm.taobao.org/mirrors/git-for-windows">https://npm.taobao.org/mirrors/git-for-windows</a></p><p>效果查看：</p><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E8%A7%A3%E5%86%B3%E5%9B%BD%E5%86%85Git%E5%AE%98%E7%BD%91%E4%B8%8B%E8%BD%BD%E5%A4%AA%E6%85%A2%E7%9A%84%E6%96%B9%E6%B3%95.png" alt="解决国内Git官网下载太慢的方法"></p>]]></content>
    
    
    <categories>
      
      <category>软件安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git使用总结</title>
    <link href="/2020/07/20/Git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2020/07/20/Git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Git使用总结"><a href="#Git使用总结" class="headerlink" title="Git使用总结"></a>Git使用总结</h1><h2 id="本地库初始化"><a href="#本地库初始化" class="headerlink" title="本地库初始化"></a>本地库初始化</h2><p>命令：git init</p><h2 id="设置签名"><a href="#设置签名" class="headerlink" title="设置签名"></a>设置签名</h2><p>用户名：hzlei</p><p>email：<a href="mailto:&#104;&#x7a;&#x6c;&#x65;&#x69;&#x40;&#102;&#x6f;&#120;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;">&#104;&#x7a;&#x6c;&#x65;&#x69;&#x40;&#102;&#x6f;&#120;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;</a></p><p>作用：区分不同开发工作人员的身份</p><p>说明：这里设置的签名和登录远程库的账号，密码没有任何关系</p><p>优先级：就近原则：项目级别&gt;系统级别，两者都有采用项目级别不允许两者都没有</p><p>命令：</p><ol><li><p>项目级别/仓库级别：仅限在本地库范围内有效</p><blockquote><p>  git config user.name hzlei<br>  git config user.email <a href="mailto:&#x68;&#x7a;&#x6c;&#101;&#x69;&#x40;&#x66;&#x6f;&#x78;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;">&#x68;&#x7a;&#x6c;&#101;&#x69;&#x40;&#x66;&#x6f;&#x78;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;</a><br>  信息保存在：./.git/config</p></blockquote></li><li><p>系统用户级别：登录当前操作系统的用户范围：</p><blockquote><p>  git config –global user.name hzlei<br>  git config –global user.email <a href="mailto:&#104;&#x7a;&#108;&#x65;&#105;&#64;&#x66;&#111;&#x78;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;">&#104;&#x7a;&#108;&#x65;&#105;&#64;&#x66;&#111;&#x78;&#x6d;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;</a><br>  信息保存在：~/.gitconfig</p></blockquote></li></ol><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 查看工作区，暂存区状态</span><br>git status<br><span class="hljs-comment">// 将工作区的“新建/修改”添加到暂存区</span><br>git add [file name]<br><span class="hljs-comment">// 将暂存区的提交到本地库</span><br>git commit -m <span class="hljs-string">&quot;commit message&quot;</span> [file name]<br><span class="hljs-comment">// 查看历史版本（详细展示）空格向下翻页，b向上翻页，q推出</span><br>git log<br><span class="hljs-comment">// 查看历史版本（其他几种展示）</span><br>git log --pretty=oneline<br>git log --oneline<br>git log reflog<span class="hljs-comment">// 到某个版本需要移动几步</span><br><span class="hljs-comment">// 配置远程仓库地址</span><br>git remote add [自己起的远程库别名，一般用origin] [远程仓库地址]<br><span class="hljs-comment">// 删除配置过的远程仓库地址</span><br>git remote remove [自己起的远程库别名]<br><span class="hljs-comment">// 查看配置的远程仓库地址</span><br>git remote -v<br><span class="hljs-comment">// 推送到远程的仓库</span><br>git push [自己起的远程库别名，一般用origin] [分支名字]<br><span class="hljs-comment">// 克隆</span><br>git clone [远程仓库地址]<br><span class="hljs-comment">// 拉取，pull = fetch + merge</span><br>git pull [自己起的远程库别名，一般用origin] [远程分支名]<br>git fetch [自己起的远程库别名/远程分支名]<br></code></pre></div></td></tr></table></figure><h2 id="版本前进后退"><a href="#版本前进后退" class="headerlink" title="版本前进后退"></a>版本前进后退</h2><ol><li><p>基于索引值操作（推荐），能前进能后退</p><blockquote><p>git reset –hard [局部索引值]</p></blockquote></li><li><p>使用 ^ 操作，只能后退，几个^，就表示后退几步</p><blockquote><p>  git reset –hard HEAD^</p></blockquote></li><li><p>使用 ~ 操作，只能后退，后退n步，在 git reflog 中能查看具体的步数</p><blockquote><p>  git reset –hard HEAD~n</p></blockquote></li></ol><h2 id="reset命令的三个参数对比"><a href="#reset命令的三个参数对比" class="headerlink" title="reset命令的三个参数对比"></a>reset命令的三个参数对比</h2><ol><li><p>–soft</p><blockquote><p>  仅仅在本地库移动下HEAD指针</p></blockquote></li><li><p>–mixed</p><blockquote><p>  在本地库移动HEAD指针</p><p>  重置暂存区</p></blockquote></li><li><p>–hard</p><blockquote><p>  在本地库移动HEAD指针</p><p>  重置暂存区</p><p>  重置工作区</p></blockquote></li></ol><h2 id="找回删除文件"><a href="#找回删除文件" class="headerlink" title="找回删除文件"></a>找回删除文件</h2><blockquote><p>  前提：删除前，文件存在时的状态提交到了本地库</p><p>  git reset –hard [指针位置]</p><p>  删除操作前已经提交到本地库：指针位置指向历史记录</p><p>  删除操作前尚未提交到本地库：指针位置使用 HEAD</p></blockquote><h2 id="比较文件差异"><a href="#比较文件差异" class="headerlink" title="比较文件差异"></a>比较文件差异</h2><blockquote><p>  将工作区中的文件和暂存区的进行比较，不带文件名，则比较多个文件</p><p>  git diff [文件名]</p><p>  将工作区的文件和本地库历史记录的比较， 不带文件名，则比较多个文件</p><p>  git diff [本地库中历史版本] [文件名]</p></blockquote><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><ol><li><p>什么时分支？</p><p> 在版本控制过程中，使用多条线同时推送多个任务。</p></li><li><p>分支的好处</p><ul><li>  同时并行推进多个功能开发，提高开发效率</li><li>  各个分支在开发过程中，如果某一个分支开发失败，不会对其他分区有任何影响</li></ul></li><li><p>分支的操作</p> <figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建分支</span><br>git branch [分支名]<br><span class="hljs-comment">// 查看分支</span><br>git branch -v<br><span class="hljs-comment">// 切换分支</span><br>git checkout [分支名]<br><span class="hljs-comment">// 合并分支</span><br><span class="hljs-comment">// 1. 切换到接受修改的分支上</span><br>git checkout [接受修改的分支名]<br><span class="hljs-comment">// 2. 执行 merge 命令</span><br>git merge [有新内容的分支名]<br></code></pre></div></td></tr></table></figure></li><li><p>解决合并分支后所产生的冲突</p><ul><li>  编辑文件，删除特殊符号</li><li>  把文件修改到满意的程度，保存退出</li><li>  git add [文件名]</li><li>  git commit -m “commit message”</li></ul></li></ol><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>要点：</p><ol><li> 如果不是基于远程库的最新版所做的修改，不能推送，必须先拉取。</li><li> 拉取下来后如果进入冲突，则要先解决冲突，再操作。</li></ol><h2 id="SSH登录"><a href="#SSH登录" class="headerlink" title="SSH登录"></a>SSH登录</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 进入当前用户的加目录</span><br>cd ~<br><span class="hljs-comment">// 删除 .ssh 目录</span><br>rm -f .ssh<br><span class="hljs-comment">// 运行命令生成 .ssh 密钥目录</span><br>ssh-keygen -t rsa -C [your email]<br><span class="hljs-comment">// 进入 .ssh 目录查看文件列表</span><br>cd .ssh<br><span class="hljs-comment">// 查看 id_rsa.pub 文件内容</span><br>cat id_rsa.pub<br><span class="hljs-comment">// 复制 id_rsa.pub 文件内容，登录Github，点击用户头像 --&gt; Settings --&gt; SSH and GPGkeys --&gt; new SSH Key</span><br><span class="hljs-comment">// 输入复制的密钥信息，保存</span><br><span class="hljs-comment">// 推送测试，注意复制远程地址的时候，要选择SSH地址</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>版本管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-冒泡排序</title>
    <link href="/2020/07/20/Java-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/07/20/Java-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-冒泡排序"><a href="#Java-冒泡排序" class="headerlink" title="Java-冒泡排序"></a>Java-冒泡排序</h1><h2 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h2><p>依次比较两个相邻的元素</p><h2 id="动图展示"><a href="#动图展示" class="headerlink" title="动图展示"></a>动图展示</h2><p><img src="https://online-education-headimg.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/bubbleSort.gif" alt="冒泡排序"></p><h2 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BubbleSort</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br><br><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">44</span>, <span class="hljs-number">38</span>, <span class="hljs-number">5</span>, <span class="hljs-number">47</span>, <span class="hljs-number">15</span>, <span class="hljs-number">36</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>, <span class="hljs-number">2</span>, <span class="hljs-number">46</span>, <span class="hljs-number">4</span>, <span class="hljs-number">19</span>, <span class="hljs-number">50</span>, <span class="hljs-number">48</span>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.length - i - <span class="hljs-number">1</span>; j++) &#123;<br><span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br><span class="hljs-keyword">int</span> temp = arr[j];<br>arr[j] = arr[j + <span class="hljs-number">1</span>];<br>arr[j + <span class="hljs-number">1</span>]  = temp;<br>&#125;<br>&#125;<br>&#125;<br>System.out.println(Arrays.toString(arr));<br><br>&#125;<br><br>&#125;<br><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于hexo和GitHub搭建个人博客</title>
    <link href="/2020/07/19/%E5%9F%BA%E4%BA%8Ehexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/07/19/%E5%9F%BA%E4%BA%8Ehexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="基于hexo和GitHub搭建个人博客"><a href="#基于hexo和GitHub搭建个人博客" class="headerlink" title="基于hexo和GitHub搭建个人博客"></a>基于hexo和GitHub搭建个人博客</h1><h2 id="课前准备"><a href="#课前准备" class="headerlink" title="课前准备"></a>课前准备</h2><ol><li>nodejs 环境（自行百度）</li><li>安装 npm（自行百度）</li><li>安装 Git（自行百度）</li><li>注册 GitHub账号</li><li>安装 hexo</li></ol><h2 id="配置-hexo"><a href="#配置-hexo" class="headerlink" title="配置 hexo"></a>配置 hexo</h2><ol><li>指定一个空文件夹，路径栏输入cmd命令，打开cmd窗口，然后运行命令 <strong>hexo init</strong></li><li>安装hexo-git工具推送代码，在此文件夹内打开cmd 窗口，运行命令<strong>npm install hexo-deployer-git –save</strong></li><li>此文件夹内打开cmd 窗口，运行命令 <strong>hexo clean &amp;&amp; hexo g</strong></li><li><strong>hexo s</strong> 命令运行项目，地址栏输入localhost:4000，就可以看到默认博客页面，然后部署到Github</li></ol><h2 id="部署到-GitHub"><a href="#部署到-GitHub" class="headerlink" title="部署到 GitHub"></a>部署到 GitHub</h2><ol><li><p>新建一个仓库，仓库名称为：**(github用户名).github.io<strong>，</strong>必须项<strong>，然后选public，之后新建，</strong>并copy仓库地址**</p></li><li><p>在项目里找到 <strong>_config.yml</strong> 文件，修改下面这个地方，保存退出</p> <figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"># Deployment<br>## Docs: https://hexo.io/docs/deployment.html<br>deploy:<br>  type: git<br>  repo: copy的仓库地址<br>  branch: master<br></code></pre></div></td></tr></table></figure></li><li><p><strong>hexo d</strong> 推送到GitHub仓库，中间可能会要求输入GitHub账号密码</p></li><li><p>推送完成之后，博客地址就是 <strong>(github用户名).github.io</strong>，比如我的<strong>573e.github.io</strong>，<a href="https://573e.github.io/">点我访问</a></p></li><li><p>到此就搭建完成了</p></li></ol><h2 id="更改主题"><a href="#更改主题" class="headerlink" title="更改主题"></a>更改主题</h2><ol><li>本人使用的主题是 fuild</li><li>fuild github：<a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></li><li>操作实例：<a href="https://hexo.fluid-dev.com/docs/example/">https://hexo.fluid-dev.com/docs/example/</a></li><li>配置指南：<a href="https://hexo.fluid-dev.com/docs/guide/">https://hexo.fluid-dev.com/docs/guide/</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>软件安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
